{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#fieldLt\"><span class=\"name\">fieldLt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of `field_simp` is to reduce an expression in a field to an expression of the form `n / d`\nwhere neither `n` nor `d` contains any division symbol.\n\nIf the goal is an (in)equality, this tactic will also clear the denominators, so that the proof\ncan normally be concluded by an application of `ring`.\n\nFor example,\n```lean\nexample (a b c d x y : ℂ) (hx : x ≠ 0) (hy : y ≠ 0) :\n    a + b / x + c / x ^ 2 + d / x ^ 3 = a + x⁻¹ * (y * b / y + (d / x + c) / x) := by\n  field_simp\n  ring\n```\n\nCancelling and combining denominators often requires \"nonzeroness\" side conditions. The `field_simp`\ntactic attempts to discharge these, and will omit such steps if it cannot discharge the\ncorresponding side conditions. The discharger will try, among other things, `positivity` and\n`norm_num`, and will also use any nonzeroness proofs included explicitly (e.g. `field_simp [hx]`).\nIf your expression is not completely reduced by `field_simp`, check the denominators of the\nresulting expression and provide proofs that they are nonzero to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#fieldLt","kind":"def","line":725,"name":"fieldLt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L725-L725"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#fieldLe\"><span class=\"name\">fieldLe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of `field_simp` is to reduce an expression in a field to an expression of the form `n / d`\nwhere neither `n` nor `d` contains any division symbol.\n\nIf the goal is an (in)equality, this tactic will also clear the denominators, so that the proof\ncan normally be concluded by an application of `ring`.\n\nFor example,\n```lean\nexample (a b c d x y : ℂ) (hx : x ≠ 0) (hy : y ≠ 0) :\n    a + b / x + c / x ^ 2 + d / x ^ 3 = a + x⁻¹ * (y * b / y + (d / x + c) / x) := by\n  field_simp\n  ring\n```\n\nCancelling and combining denominators often requires \"nonzeroness\" side conditions. The `field_simp`\ntactic attempts to discharge these, and will omit such steps if it cannot discharge the\ncorresponding side conditions. The discharger will try, among other things, `positivity` and\n`norm_num`, and will also use any nonzeroness proofs included explicitly (e.g. `field_simp [hx]`).\nIf your expression is not completely reduced by `field_simp`, check the denominators of the\nresulting expression and provide proofs that they are nonzero to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#fieldLe","kind":"def","line":724,"name":"fieldLe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L724-L724"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#fieldEq\"><span class=\"name\">fieldEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of `field_simp` is to reduce an expression in a field to an expression of the form `n / d`\nwhere neither `n` nor `d` contains any division symbol.\n\nIf the goal is an (in)equality, this tactic will also clear the denominators, so that the proof\ncan normally be concluded by an application of `ring`.\n\nFor example,\n```lean\nexample (a b c d x y : ℂ) (hx : x ≠ 0) (hy : y ≠ 0) :\n    a + b / x + c / x ^ 2 + d / x ^ 3 = a + x⁻¹ * (y * b / y + (d / x + c) / x) := by\n  field_simp\n  ring\n```\n\nCancelling and combining denominators often requires \"nonzeroness\" side conditions. The `field_simp`\ntactic attempts to discharge these, and will omit such steps if it cannot discharge the\ncorresponding side conditions. The discharger will try, among other things, `positivity` and\n`norm_num`, and will also use any nonzeroness proofs included explicitly (e.g. `field_simp [hx]`).\nIf your expression is not completely reduced by `field_simp`, check the denominators of the\nresulting expression and provide proofs that they are nonzero to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#fieldEq","kind":"def","line":723,"name":"fieldEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L723-L723"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"The goal of `field_simp` is to reduce an expression in a field to an expression of the form `n / d`\nwhere neither `n` nor `d` contains any division symbol.\n\nIf the goal is an (in)equality, this tactic will also clear the denominators, so that the proof\ncan normally be concluded by an application of `ring`.\n\nFor example,\n```lean\nexample (a b c d x y : ℂ) (hx : x ≠ 0) (hy : y ≠ 0) :\n    a + b / x + c / x ^ 2 + d / x ^ 3 = a + x⁻¹ * (y * b / y + (d / x + c) / x) := by\n  field_simp\n  ring\n```\n\nCancelling and combining denominators often requires \"nonzeroness\" side conditions. The `field_simp`\ntactic attempts to discharge these, and will omit such steps if it cannot discharge the\ncorresponding side conditions. The discharger will try, among other things, `positivity` and\n`norm_num`, and will also use any nonzeroness proofs included explicitly (e.g. `field_simp [hx]`).\nIf your expression is not completely reduced by `field_simp`, check the denominators of the\nresulting expression and provide proofs that they are nonzero to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.proc","kind":"def","line":707,"name":"Mathlib.Tactic.FieldSimp.proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L707-L717"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">convField_simp__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The goal of `field_simp` is to reduce an expression in a field to an expression of the form `n / d`\nwhere neither `n` nor `d` contains any division symbol.\n\nIf the goal is an (in)equality, this tactic will also clear the denominators, so that the proof\ncan normally be concluded by an application of `ring`.\n\nFor example,\n```lean\nexample (a b c d x y : ℂ) (hx : x ≠ 0) (hy : y ≠ 0) :\n    a + b / x + c / x ^ 2 + d / x ^ 3 = a + x⁻¹ * (y * b / y + (d / x + c) / x) := by\n  field_simp\n  ring\n```\n\nCancelling and combining denominators often requires \"nonzeroness\" side conditions. The `field_simp`\ntactic attempts to discharge these, and will omit such steps if it cannot discharge the\ncorresponding side conditions. The discharger will try, among other things, `positivity` and\n`norm_num`, and will also use any nonzeroness proofs included explicitly (e.g. `field_simp [hx]`).\nIf your expression is not completely reduced by `field_simp`, check the denominators of the\nresulting expression and provide proofs that they are nonzero to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.convField_simp__","kind":"def","line":697,"name":"Mathlib.Tactic.FieldSimp.convField_simp__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L697-L705"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">fieldSimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The goal of `field_simp` is to reduce an expression in a field to an expression of the form `n / d`\nwhere neither `n` nor `d` contains any division symbol.\n\nIf the goal is an (in)equality, this tactic will also clear the denominators, so that the proof\ncan normally be concluded by an application of `ring`.\n\nFor example,\n```lean\nexample (a b c d x y : ℂ) (hx : x ≠ 0) (hy : y ≠ 0) :\n    a + b / x + c / x ^ 2 + d / x ^ 3 = a + x⁻¹ * (y * b / y + (d / x + c) / x) := by\n  field_simp\n  ring\n```\n\nCancelling and combining denominators often requires \"nonzeroness\" side conditions. The `field_simp`\ntactic attempts to discharge these, and will omit such steps if it cannot discharge the\ncorresponding side conditions. The discharger will try, among other things, `positivity` and\n`norm_num`, and will also use any nonzeroness proofs included explicitly (e.g. `field_simp [hx]`).\nIf your expression is not completely reduced by `field_simp`, check the denominators of the\nresulting expression and provide proofs that they are nonzero to enable further progress.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.fieldSimp","kind":"def","line":666,"name":"Mathlib.Tactic.FieldSimp.fieldSimp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L666-L695"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">parseDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.discharger</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.simpArgs</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <span class=\"fn\">({<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span>)</span></span></div></div>","info":{"doc":"If the user provided a discharger, elaborate it. If not, we will use the `field_simp` default\ndischarger, which (among other things) includes a simp-run for the specified argument list, so we\nelaborate those arguments. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.parseDischarger","kind":"def","line":647,"name":"Mathlib.Tactic.FieldSimp.parseDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L647-L664"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given an (in)equality `a = b` (respectively, `a ≤ b`, `a < b`), cancel nonzero (resp. positive)\nfactors to construct a new (in)equality which is logically equivalent to `a = b` (respectively,\n`a ≤ b`, `a < b`). ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceProp","kind":"def","line":609,"name":"Mathlib.Tactic.FieldSimp.reduceProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L609-L641"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given `x` in a commutative group-with-zero, construct a new expression in the standard form\n*** / *** (all denominators at the end) which is equal to `x`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExpr","kind":"def","line":590,"name":"Mathlib.Tactic.FieldSimp.reduceExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L590-L607"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceLtQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono\">PosMulStrictMono</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT\">PosMulReflectLT</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">f₁</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">(<span class=\"fn\">f₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q((<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$e₂»</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">«$f₁»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$f₂»</span>))</span></span>)</span></span></div></div>","info":{"doc":"Given `e₁` and `e₂`, cancel positive factors to construct a new inequality which is logically\nequivalent to `e₁ < e₂`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLtQ","kind":"def","line":572,"name":"Mathlib.Tactic.FieldSimp.reduceLtQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L572-L588"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceLeQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono\">PosMulStrictMono</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLE\">PosMulReflectLE</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">f₁</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">(<span class=\"fn\">f₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q((<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">«$e₂»</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">«$f₁»</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">«$f₂»</span>))</span></span>)</span></span></div></div>","info":{"doc":"Given `e₁` and `e₂`, cancel positive factors to construct a new inequality which is logically\nequivalent to `e₁ ≤ e₂`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceLeQ","kind":"def","line":554,"name":"Mathlib.Tactic.FieldSimp.reduceLeQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L554-L570"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceEqQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">f₁</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">(<span class=\"fn\">f₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q((<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e₂»</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">«$f₁»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$f₂»</span>))</span></span>)</span></span></div></div>","info":{"doc":"Given `e₁` and `e₂`, cancel nonzero factors to construct a new equality which is logically\nequivalent to `e₁ = e₂`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceEqQ","kind":"def","line":539,"name":"Mathlib.Tactic.FieldSimp.reduceEqQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L539-L552"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">reduceExprQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">((<span class=\"fn\">x'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$x'»</span>)</span>)</span></span></div></div>","info":{"doc":"Given `x` in a commutative group-with-zero, construct a new expression in the standard form\n*** / *** (all denominators at the end) which is equal to `x`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.reduceExprQ","kind":"def","line":529,"name":"Mathlib.Tactic.FieldSimp.reduceExprQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L529-L537"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">normalize</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a>\n  <span class=\"fn\">((<span class=\"fn\">y</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) ×\n    <span class=\"fn\">((<span class=\"fn\">g</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign\">Sign</a> <span class=\"fn\">M</span></span>) ×\n        <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">g</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.Sign.expr\">expr</a></span> <span class=\"fn\">y</span></span>;\n        <span class=\"fn\">Q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a»</span>)</span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>       <span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n        <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n        <span class=\"fn\">Q(<span class=\"fn\">«$y»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"The main algorithm behind the `field_simp` tactic: partially-normalizing an\nexpression in a field `M` into the form x1 ^ c1 * x2 ^ c2 * ... x_k ^ c_k,\nwhere x1, x2, ... are distinct atoms in `M`, and c1, c2, ... are integers. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.normalize","kind":"opaque","line":410,"name":"Mathlib.Tactic.FieldSimp.normalize","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L410-L527"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">gcd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">(<span class=\"fn\">l₁'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n      <span class=\"fn\">(<span class=\"fn\">l₂'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n        <span class=\"fn\">(have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n          <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₁'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n          <span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">L</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n          <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>           <span class=\"fn\">(have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">L</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n            <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a>             <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> <span class=\"fn\">L</span> <span class=\"fn\">cond</span></span></span></span>)</span></span></div></div>","info":{"doc":"Extract a common factor `L` of two products-of-powers `l₁` and `l₂` in `M`, in the sense that\nboth `l₁` and `l₂` are quotients by `L` of products of *positive* powers.\n\nThe variable `cond` specifies whether we extract a *certified nonzero[/positive]* (and therefore\npotentially smaller) common factor. If so, the metaprogram returns a \"proof\" that this common factor\nis nonzero/positive, i.e. an expression `Q(NF.eval $(L.toNF) ≠ 0)` / `Q(0 < NF.eval $(L.toNF))`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.gcd","kind":"opaque","line":317,"name":"Mathlib.Tactic.FieldSimp.qNF.gcd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L317-L404"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">mkDenomConditionProofSucc'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hL</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> <span class=\"fn\">L</span> <span class=\"fn\">cond</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> (<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">e</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">i</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">L</span>) <span class=\"fn\">cond</span>)</span></span></div></div>","info":{"doc":"Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of\n`DenomCondition`) of a field-simp-normal-form expression `L` (a product of powers of atoms),\nconstruct a corresponding proof for `((r, e), i) :: L`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'","kind":"def","line":296,"name":"Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L296-L313"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">mkDenomConditionProofSucc</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hL</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> <span class=\"fn\">L</span> <span class=\"fn\">cond</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">DenomCondition.proof</a> (<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">e</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">i</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">L</span>) <span class=\"fn\">cond</span></span>)</span></div></div>","info":{"doc":"Given a proof of the nonzeroness, strict positivity, etc. (as specified by the value of\n`DenomCondition`) of a field-simp-normal-form expression `L` (a product of powers of atoms),\nconstruct a corresponding proof for `((r, e), i) :: L`.\n\nIn this version we also expose the proof of nonzeroness of `e`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc","kind":"def","line":274,"name":"Mathlib.Tactic.FieldSimp.mkDenomConditionProofSucc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L274-L294"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">proofZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">cond</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#inferInstance\">inferInstance</a>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\">proof</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a> <span class=\"fn\">cond</span></span></div></div>","info":{"doc":"The empty field-simp-normal-form expression `[]` (representing `1` as an empty product of powers\nof atoms) can be proved to be nonzero, strict positivity, etc., as needed, as specified by the\nvalue of `DenomCondition`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proofZero","kind":"def","line":263,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.proofZero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L263-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">proof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">L</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span> → <a href=\"./foundational_types.html\">Type</a></span></div></div>","info":{"doc":"Given a field-simp-normal-form expression `L` (a product of powers of atoms), a proof (according\nto the value of `DenomCondition`) of that expression's nonzeroness, strict positivity, etc. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.proof","kind":"def","line":256,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.proof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L256-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.positive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">positive</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Defs/PartialOrder.html#PartialOrder\">PartialOrder</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulStrictMono\">PosMulStrictMono</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM'''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.html#PosMulReflectLT\">PosMulReflectLT</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM''''</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Order/ZeroLEOne.html#ZeroLEOneClass\">ZeroLEOneClass</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.positive","kind":"ctor","line":251,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.positive","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L251-L252"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.nonzero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">nonzero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.nonzero","kind":"ctor","line":250,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.nonzero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L250-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.none\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span>.<span class=\"name\">none</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\">DenomCondition</a> <span class=\"fn\">iM</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition.none","kind":"ctor","line":249,"name":"Mathlib.Tactic.FieldSimp.DenomCondition.none","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L249-L249"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">DenomCondition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Constraints on denominators which may need to be considered in `field_simp`: no condition,\nnonzeroness, or strict positivity. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.DenomCondition","kind":"inductive","line":246,"name":"Mathlib.Tactic.FieldSimp.DenomCondition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L246-L252"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkDivProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div\">div</a></span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), recursively construct a proof that in the field `$M`, the quotient\nof the \"multiplicative linear combinations\" represented by `l₁` and `l₂` is the multiplicative\nlinear combination represented by `FieldSimp.qNF.div l₁ l₁`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkDivProof","kind":"def","line":224,"name":"Mathlib.Tactic.FieldSimp.qNF.mkDivProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L224-L242"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">div</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), construct another such term `l`, which will have the property that in\nthe field `$M`, the quotient of the \"multiplicative linear combinations\" represented by `l₁` and\n`l₂` is the multiplicative linear combination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly decreasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the first list and the negation of the second list, except\nthat if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with the same\n`ℕ`-component `k`, then contribute a term `(a₁ - a₂, x₁)` to the output list with `ℕ`-component `k`.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.div","kind":"def","line":200,"name":"Mathlib.Tactic.FieldSimp.qNF.div","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L200-L222"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mkMulProof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l₁ </span><span class=\"fn\">l₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul\">mul</a></span> <span class=\"fn\">l₂</span>)</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l₂</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l₁</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n<span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), recursively construct a proof that in the field `$M`, the product of\nthe \"multiplicative linear combinations\" represented by `l₁` and `l₂` is the multiplicative linear\ncombination represented by `FieldSimp.qNF.mul l₁ l₁`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mkMulProof","kind":"def","line":180,"name":"Mathlib.Tactic.FieldSimp.qNF.mkMulProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L180-L198"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span></span></div></div>","info":{"doc":"Given two terms `l₁`, `l₂` of type `qNF M`, i.e. lists of `(ℤ × Q($M)) × ℕ`s (an integer, an\n`Expr` and a natural number), construct another such term `l`, which will have the property that in\nthe field `$M`, the product of the \"multiplicative linear combinations\" represented by `l₁` and\n`l₂` is the multiplicative linear combination represented by `l`.\n\nThe construction assumes, to be valid, that the lists `l₁` and `l₂` are in strictly decreasing order\nby `ℕ`-component, and that if pairs `(a₁, x₁)` and `(a₂, x₂)` appear in `l₁`, `l₂` respectively with\nthe same `ℕ`-component `k`, then the expressions `x₁` and `x₂` are equal.\n\nThe construction is as follows: merge the two lists, except that if pairs `(a₁, x₁)` and `(a₂, x₂)`\nappear in `l₁`, `l₂` respectively with the same `ℕ`-component `k`, then contribute a term\n`(a₁ + a₂, x₁)` to the output list with `ℕ`-component `k`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.mul","kind":"def","line":155,"name":"Mathlib.Tactic.FieldSimp.qNF.mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L155-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">evalPretty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) ×\n    <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e»</span>)</span></span>)</span></span></div></div>","info":{"doc":"Build a transparent expression for the product of powers represented by `l : qNF M`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPretty","kind":"def","line":140,"name":"Mathlib.Tactic.FieldSimp.qNF.evalPretty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L140-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">split</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">l_n</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">(<span class=\"fn\">l_d</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n      <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l_d</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n      <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l_n</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n      <span class=\"fn\">have <span class=\"fn\">a_2</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n      <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_2»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span></span></span>)</span></span></div></div>","info":{"doc":"Given a product of powers, split as a quotient: the positive powers divided by (the negations\nof) the negative powers. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.split","kind":"def","line":109,"name":"Mathlib.Tactic.FieldSimp.qNF.split","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L109-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">removeZeros</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">l'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Given `l : qNF M`, obtain `l' : qNF M` by removing all `l`'s exponent-zero entries where the\ncorresponding atom can be proved nonzero, and construct a proof that their associated expressions\nare equal. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.removeZeros","kind":"def","line":92,"name":"Mathlib.Tactic.FieldSimp.qNF.removeZeros","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L92-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">tryClearZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch</span> : <span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>) → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#CommGroupWithZero\">CommGroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a>\n  <span class=\"fn\">((<span class=\"fn\">l'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>) ×\n    <span class=\"fn\">have <span class=\"fn\">a</span> := <span class=\"fn\"><span class=\"fn\">l'</span>.<a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a></span>;\n    <span class=\"fn\">have <span class=\"fn\">a_1</span> := <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\">toNF</a> (<a href=\"./Init/Prelude.html#Prod.mk\">(</a><a href=\"./Init/Prelude.html#Prod.mk\">(</a><span class=\"fn\">r</span><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">x</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a><a href=\"./Init/Prelude.html#Prod.mk\">,</a> <span class=\"fn\">i</span><a href=\"./Init/Prelude.html#Prod.mk\">)</a> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">l</span>)</span>;\n    <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a_1»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">«$a»</span>.<a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF.eval\">eval</a></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Try to drop an expression `zpow' x r` from the beginning of a product. If `r ≠ 0` this of course\ncan't be done. If `r = 0`, then `zpow' x r` is equal to `x / x`, so it can be simplified to 1 (hence\ndropped from the beginning of the product) if we can find a proof that `x ≠ 0`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.tryClearZero","kind":"def","line":76,"name":"Mathlib.Tactic.FieldSimp.qNF.tryClearZero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L76-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">evalPrettyMonomial</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">iM</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/GroupWithZero/Defs.html#GroupWithZero\">GroupWithZero</a> <span class=\"fn\">«$M»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$M»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.zpow'\">zpow'</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$r»</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e»</span>)</span>)</span></span></div></div>","info":{"doc":"Build a transparent expression for the product of powers represented by `l : qNF M`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial","kind":"def","line":62,"name":"Mathlib.Tactic.FieldSimp.qNF.evalPrettyMonomial","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L62-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">onExponent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">M</span></span></div></div>","info":{"doc":"Given `l` of type `qNF M`, i.e. a list of `(ℤ × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), apply an expression representing a function with domain `ℤ` to each of the `ℤ`\ncomponents. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.onExponent","kind":"def","line":56,"name":"Mathlib.Tactic.FieldSimp.qNF.onExponent","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L56-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span>.<span class=\"name\">toNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\">qNF</a> <span class=\"fn\">q(<span class=\"fn\">«$M»</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/FieldSimp/Lemmas.html#Mathlib.Tactic.FieldSimp.NF\">NF</a> <span class=\"fn\">«$M»</span></span>)</span></div></div>","info":{"doc":"Given `l` of type `qNF M`, i.e. a list of `(ℤ × Q($M)) × ℕ`s (two `Expr`s and a natural\nnumber), build an `Expr` representing an object of type `NF M` (i.e. `List (ℤ × M)`) in the\nin the obvious way: by forgetting the natural numbers and gluing together the integers and `Expr`s.\n","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF.toNF","kind":"def","line":47,"name":"Mathlib.Tactic.FieldSimp.qNF.toNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L47-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">FieldSimp</span>.<span class=\"name\">qNF</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Basic meta-code \"normal form\" object of the `field_simp` tactic: a type synonym\nfor a list of ordered triples comprising an expression representing a term of a type `M` (where\ntypically `M` is a field), together with an integer \"power\" and a natural number \"index\".\n\nThe natural number represents the index of the `M` term in the `AtomM` monad: this is not enforced,\nbut is sometimes assumed in operations.  Thus when items `((a₁, x₁), k)` and `((a₂, x₂), k)`\nappear in two different `FieldSimp.qNF` objects (i.e. with the same `ℕ`-index `k`), it is expected\nthat the expressions `x₁` and `x₂` are the same.  It is also expected that the items in a\n`FieldSimp.qNF` list are in strictly decreasing order by natural-number index.\n\nBy forgetting the natural number indices, an expression representing a `Mathlib.Tactic.FieldSimp.NF`\nobject can be built from a `FieldSimp.qNF` object; this construction is provided as\n`Mathlib.Tactic.FieldSimp.qNF.toNF`. ","docLink":"./Mathlib/Tactic/FieldSimp.html#Mathlib.Tactic.FieldSimp.qNF","kind":"def","line":30,"name":"Mathlib.Tactic.FieldSimp.qNF","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/FieldSimp.lean#L30-L43"}}],"imports":["Init","Mathlib.Data.Ineq","Mathlib.Tactic.FieldSimp.Attr","Mathlib.Tactic.FieldSimp.Discharger","Mathlib.Tactic.FieldSimp.Lemmas","Mathlib.Util.AtLocation","Mathlib.Util.AtomM.Recurse","Mathlib.Util.SynthesizeUsing"],"instances":[],"name":"Mathlib.Tactic.FieldSimp"}
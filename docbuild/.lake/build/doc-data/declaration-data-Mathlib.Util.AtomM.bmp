{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtomQ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">addAtomQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> (<a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Subtype\">{</a> <span class=\"fn\">e'</span> <a href=\"./Init/Prelude.html#Subtype\">:</a> <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> <a href=\"./Init/Prelude.html#Subtype\">//</a> <span class=\"fn\"><span class=\"fn\">«$e»</span> =Q <span class=\"fn\">«$e'»</span></span> <a href=\"./Init/Prelude.html#Subtype\">}</a>)</span></div></div>","info":{"doc":"If an atomic expression has already been encountered, get the index and the stored form of the\natom (which will be defeq at the specified transparency, but not necessarily syntactically equal).\nIf the atomic expression has *not* already been encountered, store it in the list of atoms, and\nreturn the new index (and the stored form of the atom, which will be itself).\n\nIn a normalizing tactic, the expression returned by `addAtomQ` should be considered the normal form.\n\nThis is a strongly-typed version of `AtomM.addAtom` for code using `Qq`.\n","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtomQ","kind":"def","line":71,"name":"Mathlib.Tactic.AtomM.addAtomQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L71-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">addAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> (<a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"If an atomic expression has already been encountered, get the index and the stored form of the\natom (which will be defeq at the specified transparency, but not necessarily syntactically equal).\nIf the atomic expression has *not* already been encountered, store it in the list of atoms, and\nreturn the new index (and the stored form of the atom, which will be itself).\n\nIn a normalizing tactic, the expression returned by `addAtom` should be considered the normal form.\n","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.addAtom","kind":"def","line":56,"name":"Mathlib.Tactic.AtomM.addAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L56-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.isDefEqSafe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">isDefEqSafe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"A safe version of `isDefEq` that doesn't throw errors. We use it to avoid\n\"unknown free variable '_fvar.102937'\" errors when there may be out-of-scope free variables.\n\nTODO: don't catch any other errors\n","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.isDefEqSafe","kind":"def","line":48,"name":"Mathlib.Tactic.isDefEqSafe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L48-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.run\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">evalAtom</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span> := <span class=\"fn\">fun (<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result.mk\">{</a> <span class=\"fn\">expr</span> := <span class=\"fn\">e</span> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result.mk\">}</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Run a computation in the `AtomM` monad. ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.run","kind":"def","line":42,"name":"Mathlib.Tactic.AtomM.run","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L42-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The monad that `ring` works in. This is only used for collecting atoms. ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM","kind":"def","line":39,"name":"Mathlib.Tactic.AtomM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L39-L40"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State.atoms\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">State</span>.<span class=\"name\">atoms</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">State</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"The list of atoms-up-to-defeq encountered thus far, used for atom sorting. ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State.atoms","kind":"def","line":37,"name":"Mathlib.Tactic.AtomM.State.atoms","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L37-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">State</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">atoms</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">State</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State.mk","kind":"ctor","line":35,"name":"Mathlib.Tactic.AtomM.State.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L35-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">State</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The mutable state of the `AtomM` monad. ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State","kind":"structure","line":34,"name":"Mathlib.Tactic.AtomM.State","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L34-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">instInhabitedContext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\">Context</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext","kind":"instance","line":32,"name":"Mathlib.Tactic.AtomM.instInhabitedContext","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">instInhabitedContext</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\">Context</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.instInhabitedContext.default","kind":"def","line":32,"name":"Mathlib.Tactic.AtomM.instInhabitedContext.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">Context</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>","info":{"doc":"A simplification to apply to atomic expressions when they are encountered,\nbefore interning them in the atom list. ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context.evalAtom","kind":"def","line":31,"name":"Mathlib.Tactic.AtomM.Context.evalAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L31-L31"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context.red\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">Context</span>.<span class=\"name\">red</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>","info":{"doc":"The reducibility setting for definitional equality of atoms ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context.red","kind":"def","line":28,"name":"Mathlib.Tactic.AtomM.Context.red","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L28-L28"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">red</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">evalAtom</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\">Context</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context.mk","kind":"ctor","line":26,"name":"Mathlib.Tactic.AtomM.Context.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L26-L26"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">AtomM</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The context (read-only state) of the `AtomM` monad. ","docLink":"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context","kind":"structure","line":25,"name":"Mathlib.Tactic.AtomM.Context","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Util/AtomM.lean#L25-L32"}}],"imports":["Init","Mathlib.Init","Lean.Meta.Tactic.Simp.Types","Qq"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.AtomM.instInhabitedContext","typeNames":["Mathlib.Tactic.AtomM.Context"]}],"name":"Mathlib.Util.AtomM"}
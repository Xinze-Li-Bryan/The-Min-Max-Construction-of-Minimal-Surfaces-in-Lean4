{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveFalseByLinarith.detailTrace\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">proveFalseByLinarith</span>.<span class=\"name\">detailTrace</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"Log `f` under `linarith.detail`, with exception emojis and the provided name. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveFalseByLinarith.detailTrace","kind":"def","line":239,"name":"Mathlib.Tactic.Linarith.proveFalseByLinarith.detailTrace","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L239-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveFalseByLinarith\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">proveFalseByLinarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">transparency</span> : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oracle</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.CertificateOracle\">CertificateOracle</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">discharger</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span></div></div>","info":{"doc":"`proveFalseByLinarith` is the main workhorse of `linarith`.\nGiven a list `l` of proofs of `tᵢ Rᵢ 0`,\nit tries to derive a contradiction from `l` and use this to produce a proof of `False`.\n\n`oracle : CertificateOracle` is used to search for a certificate of unsatisfiability.\n\nThe returned certificate is a map `m` from hypothesis indices to natural number coefficients.\nIf our set of hypotheses has the form `{tᵢ Rᵢ 0}`,\nthen the elimination process should have guaranteed that\n1.\\ `∑ (m i)*tᵢ = 0`,\nwith at least one `i` such that `m i > 0` and `Rᵢ` is `<`.\n\nWe have also that\n2.\\ `∑ (m i)*tᵢ < 0`,\nsince for each `i`, `(m i)*tᵢ ≤ 0` and at least one is strictly negative.\nSo we conclude a contradiction `0 < 0`.\n\nIt remains to produce proofs of (1) and (2). (1) is verified by calling the provided `discharger`\ntactic, which is typically `ring`. We prove (2) by folding over the set of hypotheses.\n\n`transparency : TransparencyMode` controls the transparency level with which atoms are identified.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveFalseByLinarith","kind":"def","line":167,"name":"Mathlib.Tactic.Linarith.proveFalseByLinarith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L167-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveEqZeroUsing\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">proveEqZeroUsing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.proveEqZeroUsing","kind":"def","line":157,"name":"Mathlib.Tactic.Linarith.proveEqZeroUsing","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L157-L163"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addNegEqProofs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addNegEqProofs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></span></div></div>","info":{"doc":"`addNegEqProofs l` inspects the list of proofs `l` for proofs of the form `t = 0`. For each such\nproof, it adds a proof of `-t = 0` to the list.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addNegEqProofs","kind":"def","line":142,"name":"Mathlib.Tactic.Linarith.addNegEqProofs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L142-L155"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkNegOneLtZeroProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkNegOneLtZeroProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tp</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mkNegOneLtZeroProof tp` returns a proof of `-1 < 0`,\nwhere the numerals are natively of type `tp`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkNegOneLtZeroProof","kind":"def","line":134,"name":"Mathlib.Tactic.Linarith.mkNegOneLtZeroProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L134-L140"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.typeOfIneqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">typeOfIneqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"If `prf` is a proof of `t R s`, `typeOfIneqProof prf` returns the type of `t`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.typeOfIneqProof","kind":"def","line":129,"name":"Mathlib.Tactic.Linarith.typeOfIneqProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L129-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.leftOfIneqProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">leftOfIneqProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"If `prf` is a proof of `t R s`, `leftOfIneqProof prf` returns `t`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.leftOfIneqProof","kind":"def","line":124,"name":"Mathlib.Tactic.Linarith.leftOfIneqProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L124-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkLTZeroProof.step\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkLTZeroProof</span>.<span class=\"name\">step</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf </span><span class=\"fn\">npf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">coeff</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"`step c pf npf coeff` assumes that `pf` is a proof of `t1 R1 0` and `npf` is a proof\nof `t2 R2 0`. It uses `mkSingleCompZeroOf` to prove `t1 + coeff*t2 R 0`, and returns `R`\nalong with this proof.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkLTZeroProof.step","kind":"def","line":119,"name":"Mathlib.Tactic.Linarith.mkLTZeroProof.step","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L119-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkLTZeroProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkLTZeroProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>","info":{"doc":"`mkLTZeroProof coeffs pfs` takes a list of proofs of the form `tᵢ Rᵢ 0`,\npaired with coefficients `cᵢ`.\nIt produces a proof that `∑cᵢ * tᵢ R 0`, where `R` is as strong as possible.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mkLTZeroProof","kind":"def","line":99,"name":"Mathlib.Tactic.Linarith.mkLTZeroProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L99-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addIneq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a> → <a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Data/Ineq.html#Mathlib.Ineq\">Ineq</a></span></div></div>","info":{"doc":"If our goal is to add together two inequalities `t1 R1 0` and `t2 R2 0`,\n`addIneq R1 R2` produces the strength of the inequality in the sum `R`,\nalong with the name of a lemma to apply in order to conclude `t1 + t2 R 0`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addIneq","kind":"def","line":83,"name":"Mathlib.Tactic.Linarith.addIneq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L83-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addExprs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>","info":{"doc":"`addExprs L` creates an `Expr` representing the sum of the elements of `L`, associated left. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs","kind":"def","line":74,"name":"Mathlib.Tactic.Linarith.addExprs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L74-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs'.go\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addExprs'</span>.<span class=\"name\">go</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span> → <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span></div></div>","info":{"doc":"Inner loop for `addExprs'`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs'.go","kind":"def","line":69,"name":"Mathlib.Tactic.Linarith.addExprs'.go","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L69-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">addExprs'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#AddMonoid\">AddMonoid</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span> → <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span></div></div>","info":{"doc":"A type-safe analogue of `addExprs`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.addExprs'","kind":"def","line":63,"name":"Mathlib.Tactic.Linarith.addExprs'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L63-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mulExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`mulExpr n e` creates an `Expr` representing `n*e`.\nWhen elaborated, the coefficient will be a native numeral of the same type as `e`.\n","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr","kind":"def","line":54,"name":"Mathlib.Tactic.Linarith.mulExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L54-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mulExpr'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></div></div>","info":{"doc":"A typesafe version of `mulExpr`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Mathlib.Tactic.Linarith.mulExpr'","kind":"def","line":48,"name":"Mathlib.Tactic.Linarith.mulExpr'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L48-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Verification.html#Qq.ofNatQ\"><span class=\"name\">Qq</span>.<span class=\"name\">ofNatQ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> :\n  <span class=\"fn\">have <span class=\"fn\">u</span> := <span class=\"fn\">u</span>;\n  <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>) → <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></span></span></div></div>","info":{"doc":"Typesafe conversion of `n : ℕ` to `Q($α)`. ","docLink":"./Mathlib/Tactic/Linarith/Verification.html#Qq.ofNatQ","kind":"def","line":28,"name":"Qq.ofNatQ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Linarith/Verification.lean#L28-L37"}}],"imports":["Init","Mathlib.Tactic.Linarith.Parsing","Mathlib.Util.Qq"],"instances":[],"name":"Mathlib.Tactic.Linarith.Verification"}
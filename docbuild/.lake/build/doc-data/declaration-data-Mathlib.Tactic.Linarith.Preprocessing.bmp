{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.preprocess\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">preprocess</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Branch\">Branch</a>)</span></span></div></div>","info":{"doc":"`preprocess pps l` takes a list `l` of proofs of propositions.\nIt maps each preprocessor `pp ∈ pps` over this list.\nThe preprocessors are run sequentially: each receives the output of the previous one.\nNote that a preprocessor may produce multiple or no expressions from each input expression,\nso the size of the list may change.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.preprocess","kind":"def","line":394,"name":"Mathlib.Tactic.Linarith.preprocess","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L394-L406"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.defaultPreprocessors\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">defaultPreprocessors</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></span></div></div>","info":{"doc":"The default list of preprocessors, in the order they should typically run.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.defaultPreprocessors","kind":"def","line":387,"name":"Mathlib.Tactic.Linarith.defaultPreprocessors","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L387-L392"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">removeNe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></div></div>","info":{"doc":"`removeNe` case splits on any proof `h : a ≠ b` in the input, turning it into `a < b ∨ a > b`,\nby calling `linarith.removeNe_aux`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe","kind":"def","line":376,"name":"Mathlib.Tactic.Linarith.removeNe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L376-L383"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe_aux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">removeNe_aux</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Branch\">Branch</a>)</span></span></span></span></div></div>","info":{"doc":"`removeNe_aux` case splits on any proof `h : a ≠ b` in the input,\nturning it into `a < b ∨ a > b`.\nThis produces `2^n` branches when there are `n` such hypotheses in the input.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNe_aux","kind":"opaque","line":358,"name":"Mathlib.Tactic.Linarith.removeNe_aux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L358-L374"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.nlinarithExtras\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">nlinarithExtras</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalPreprocessor\">GlobalPreprocessor</a></div></div>","info":{"doc":"`nlinarithExtras` is the preprocessor corresponding to the `nlinarith` tactic.\n\n* For every term `t` such that `t^2` or `t*t` appears in the input, adds a proof of `t^2 ≥ 0`\n  or `t*t ≥ 0`.\n* For every pair of comparisons `t1 R1 0` and `t2 R2 0`, adds a proof of `t1*t2 R 0`.\n\nThis preprocessor is typically run last, after all inputs have been canonized.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.nlinarithExtras","kind":"def","line":339,"name":"Mathlib.Tactic.Linarith.nlinarithExtras","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L339-L353"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.findSquares\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">findSquares</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>) <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>) <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a>)</span></span></div></div>","info":{"doc":"`findSquares s e` collects all terms of the form `a ^ 2` and `a * a` that appear in `e`\nand adds them to the set `s`.\nA pair `(i, true)` is added to `s` when `atoms[i]^2` appears in `e`,\nand `(i, false)` is added to `s` when `atoms[i]*atoms[i]` appears in `e`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.findSquares","kind":"opaque","line":265,"name":"Mathlib.Tactic.Linarith.findSquares","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L265-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.cancelDenoms\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">cancelDenoms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"`cancelDenoms pf` assumes `pf` is a proof of `t R 0`. If `t` contains the division symbol `/`,\nit tries to scale `t` to cancel out division by numerals.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.cancelDenoms","kind":"def","line":250,"name":"Mathlib.Tactic.Linarith.cancelDenoms","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L250-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.normalizeDenominatorsLHS\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">normalizeDenominatorsLHS</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h </span><span class=\"fn\">lhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"`normalizeDenominatorsLHS h lhs` assumes that `h` is a proof of `lhs R 0`.\nIt creates a proof of `lhs' R 0`, where all numeric division in `lhs` has been cancelled.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.normalizeDenominatorsLHS","kind":"def","line":232,"name":"Mathlib.Tactic.Linarith.normalizeDenominatorsLHS","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L232-L248"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.without_one_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">without_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">M</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Defs.html#MulOneClass\">MulOneClass</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">M</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.without_one_mul","kind":"theorem","line":229,"name":"Mathlib.Tactic.Linarith.without_one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L229-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.compWithZero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">compWithZero</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"`compWithZero h` takes a proof `h` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.compWithZero","kind":"def","line":217,"name":"Mathlib.Tactic.Linarith.compWithZero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L217-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.rearrangeComparison\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">rearrangeComparison</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"`rearrangeComparison e` takes a proof `e` of an equality, inequality, or negation thereof,\nand turns it into a proof of a comparison `_ R 0`, where `R ∈ {=, ≤, <}`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.rearrangeComparison","kind":"def","line":207,"name":"Mathlib.Tactic.Linarith.rearrangeComparison","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L207-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.strengthenStrictInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">strengthenStrictInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"`strengthenStrictInt h` turns a proof `h` of a strict integer inequality `t1 < t2`\ninto a proof of `t1 ≤ t2 + 1`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.strengthenStrictInt","kind":"def","line":197,"name":"Mathlib.Tactic.Linarith.strengthenStrictInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L197-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mkNonstrictIntProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkNonstrictIntProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `pf` is a proof of a strict inequality `(a : ℤ) < b`,\n`mkNonstrictIntProof pf` returns a proof of `a + 1 ≤ b`,\nand similarly if `pf` proves a negated weak inequality.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mkNonstrictIntProof","kind":"def","line":183,"name":"Mathlib.Tactic.Linarith.mkNonstrictIntProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L183-L195"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.natToInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">natToInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.GlobalBranchingPreprocessor\">GlobalBranchingPreprocessor</a></div></div>","info":{"doc":"If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.natToInt","kind":"def","line":140,"name":"Mathlib.Tactic.Linarith.natToInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L140-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.Expr.Ord\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">Expr</span>.<span class=\"name\">Ord</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">_root_.Ord</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Ordering on `Expr`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.Expr.Ord","kind":"def","line":132,"name":"Mathlib.Tactic.Linarith.Expr.Ord","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L132-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mk_natCast_nonneg_prf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mk_natCast_nonneg_prf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `e : ℕ`, returns a proof of `0 ≤ (e : C)`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.mk_natCast_nonneg_prf","kind":"def","line":124,"name":"Mathlib.Tactic.Linarith.mk_natCast_nonneg_prf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L124-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.getNatComparisons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">getNatComparisons</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"`getNatComparisons e` returns a list of all subexpressions of `e` of the form `((t : ℕ) : C)`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.getNatComparisons","kind":"opaque","line":111,"name":"Mathlib.Tactic.Linarith.getNatComparisons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L111-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatCoe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">isNatCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"If `e` is of the form `((n : ℕ) : C)`, `isNatCoe e` returns `⟨n, C⟩`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatCoe","kind":"def","line":105,"name":"Mathlib.Tactic.Linarith.isNatCoe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L105-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">isNatProp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"`isNatProp tp` is true iff `tp` is an inequality or equality between natural numbers\nor the negation thereof.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.isNatProp","kind":"def","line":98,"name":"Mathlib.Tactic.Linarith.isNatProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L98-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNegations\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">removeNegations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"Replaces proofs of negations of comparisons with proofs of the reversed comparisons.\nFor example, a proof of `¬ a < b` will become a proof of `a ≥ b`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.removeNegations","kind":"def","line":75,"name":"Mathlib.Tactic.Linarith.removeNegations","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L75-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.flipNegatedComparison\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">flipNegatedComparison</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `prf` is a proof of `¬ e`, where `e` is a comparison,\n`flipNegatedComparison prf e` flips the comparison in `e` and returns a proof.\nFor example, if `prf : ¬ a < b`, ``flipNegatedComparison prf q(a < b)`` returns a proof of `a ≥ b`.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.flipNegatedComparison","kind":"def","line":64,"name":"Mathlib.Tactic.Linarith.flipNegatedComparison","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L64-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.filterComparisons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">filterComparisons</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"Removes any expressions that are not proofs of inequalities, equalities, or negations thereof.\n","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.filterComparisons","kind":"def","line":50,"name":"Mathlib.Tactic.Linarith.filterComparisons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L50-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.splitConjunctions.aux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">splitConjunctions</span>.<span class=\"name\">aux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Implementation of the `splitConjunctions` preprocessor. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.splitConjunctions.aux","kind":"opaque","line":43,"name":"Mathlib.Tactic.Linarith.splitConjunctions.aux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L43-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.splitConjunctions\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">splitConjunctions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Preprocessor\">Preprocessor</a></div></div>","info":{"doc":"Processor that recursively replaces `P ∧ Q` hypotheses with the pair `P` and `Q`. ","docLink":"./Mathlib/Tactic/Linarith/Preprocessing.html#Mathlib.Tactic.Linarith.splitConjunctions","kind":"def","line":37,"name":"Mathlib.Tactic.Linarith.splitConjunctions","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Linarith/Preprocessing.lean#L37-L48"}}],"imports":["Init","Mathlib.Tactic.Linarith.Datatypes","Mathlib.Tactic.Zify","Mathlib.Tactic.CancelDenoms.Core","Mathlib.Control.Basic","Mathlib.Util.AtomM"],"instances":[],"name":"Mathlib.Tactic.Linarith.Preprocessing"}
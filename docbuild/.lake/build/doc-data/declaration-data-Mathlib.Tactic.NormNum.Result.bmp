{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.eqTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">eqTrans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$b»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">a</span></span></span></div></div>","info":{"doc":"If `a = b` and we can evaluate `b`, then we can evaluate `a`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.eqTrans","kind":"def","line":555,"name":"Mathlib.Meta.NormNum.Result.eqTrans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L555-L572"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofBoolResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofBoolResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">prf</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.BoolResult\">BoolResult</a> <span class=\"fn\">p</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<a href=\"./foundational_types.html\">Prop</a>)</span></span></div></div>","info":{"doc":"Obtain a `Result` from a `BoolResult`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofBoolResult","kind":"def","line":551,"name":"Mathlib.Meta.NormNum.Result.ofBoolResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L551-L553"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.BoolResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">BoolResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Given `Mathlib.Meta.NormNum.Result.isBool p b`, this is the type of `p`.\nNote that `BoolResult p b` is definitionally equal to `Expr`, and if you write `match b with ...`,\nthen in the `true` branch `BoolResult p true` is reducibly equal to `Q($p)` and\nin the `false` branch it is reducibly equal to `Q(¬ $p)`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.BoolResult","kind":"def","line":544,"name":"Mathlib.Meta.NormNum.BoolResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L544-L549"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toSimpResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toSimpResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>","info":{"doc":"Convert a `Result` to a `Simp.Result`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toSimpResult","kind":"def","line":526,"name":"Mathlib.Meta.NormNum.Result.toSimpResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L526-L542"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw rat cast.\nAssumes `e` is a raw rat cast expression denoting `n`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawRat","kind":"def","line":513,"name":"Mathlib.Meta.NormNum.Result.ofRawRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L513-L524"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw rat cast.\nAssumes `e` is a raw rat cast expression denoting `n`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNNRat","kind":"def","line":501,"name":"Mathlib.Meta.NormNum.Result.ofRawNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L501-L511"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw int cast.\nAssumes `e` is a raw int cast expression denoting `n`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawInt","kind":"def","line":492,"name":"Mathlib.Meta.NormNum.Result.ofRawInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L492-L499"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">ofRawNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"Constructs a `Result` out of a raw nat cast. Assumes `e` is a raw nat cast expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.ofRawNat","kind":"def","line":487,"name":"Mathlib.Meta.NormNum.Result.ofRawNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L487-L490"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawIntEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRawIntEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">e'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e'»</span>)</span></span>)</span></span></div></div>","info":{"doc":"`Result.toRawEq` but providing an integer. Given a `NormNum.Result e` for something known to be an\ninteger (which uses `IsNat` or `IsInt` to express equality to an integer numeral), converts it to\nan equality `e = Nat.rawCast n` or `e = Int.rawCast n` to a raw cast expression, so it can be used\nfor rewriting. Gives `none` if not an integer.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawIntEq","kind":"def","line":475,"name":"Mathlib.Meta.NormNum.Result.toRawIntEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L475-L485"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRawEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\">(<span class=\"fn\">e'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e'»</span>)</span></span></span></div></div>","info":{"doc":"Given a `NormNum.Result e` (which uses `IsNat`, `IsInt`, `IsRat` to express equality to a rational\nnumeral), converts it to an equality `e = Nat.rawCast n`, `e = Int.rawCast n`, or\n`e = Rat.rawCast n d` to a raw cast expression, so it can be used for rewriting.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRawEq","kind":"def","line":458,"name":"Mathlib.Meta.NormNum.Result.toRawEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L458-L473"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_i</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> := by with_reducible assumption)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>) × <span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Extract from a `Result` the rational value (as both a term and an expression),\nand the proof that the original expression is equal to this rational number.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat'","kind":"def","line":438,"name":"Mathlib.Meta.NormNum.Result.toRat'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L438-L456"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toNNRat'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toNNRat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_i</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> := by with_reducible assumption)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span></span></span>)</span></span></div></div>","info":{"doc":"Extract from a `Result` the rational value (as both a term and an expression),\nand the proof that the original expression is equal to this rational number.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toNNRat'","kind":"def","line":425,"name":"Mathlib.Meta.NormNum.Result.toNNRat'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L425-L436"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_i</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> := by with_reducible assumption)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">«$lit»</span></span>)</span></span>)</span></span></div></div>","info":{"doc":"Extract from a `Result` the integer value (as both a term and an expression),\nand the proof that the original expression is equal to this integer.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toInt","kind":"def","line":413,"name":"Mathlib.Meta.NormNum.Result.toInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L413-L423"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRatNZ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRatNZ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>","info":{"doc":"Returns the rational number that is the result of `norm_num` evaluation, along with a proof\nthat the denominator is nonzero in the `isRat` case. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRatNZ","kind":"def","line":404,"name":"Mathlib.Meta.NormNum.Result.toRatNZ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L404-L411"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">toRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a></span></span></div></div>","info":{"doc":"Returns the rational number that is the result of `norm_num` evaluation. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.toRat","kind":"def","line":396,"name":"Mathlib.Meta.NormNum.Result.toRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L396-L402"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instToMessageDataResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instToMessageDataResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instToMessageDataResult","kind":"instance","line":387,"name":"Mathlib.Meta.NormNum.instToMessageDataResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L387-L394"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `q : ℚ` and `proof : isRat x q`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isRat","kind":"def","line":371,"name":"Mathlib.Meta.NormNum.Result.isRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L371-L384"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNNRat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `q : NNRat` and `proof : isNNRat x q`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat'","kind":"def","line":360,"name":"Mathlib.Meta.NormNum.Result.isNNRat'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L360-L369"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">z</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$z»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `z : ℤ` and `proof : isNat x z`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isInt","kind":"def","line":348,"name":"Mathlib.Meta.NormNum.Result.isInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L348-L358"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNegNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">«$n»</span>)</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `proof : IsRat x n d`,\nwhere `n` is `.negOfNat lit` with `lit` a raw nat literal,\n`d` is a raw nat literal (not 0 or 1),\n`n` and `d` are coprime, and `q` is the value of `n / d`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNNRat","kind":"def","line":338,"name":"Mathlib.Meta.NormNum.Result.isNegNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L338-L344"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$d»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `proof : IsNNRat x n d`,\nwhere `n` a raw nat literal, `d` is a raw nat literal (not 0 or 1),\n`n` and `d` are coprime, and `q` is the value of `n / d`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNNRat","kind":"def","line":331,"name":"Mathlib.Meta.NormNum.Result.isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L331-L336"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNegNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">«$lit»</span>)</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `-lit` where `lit` is a raw nat literal\nand `proof : isInt x (.negOfNat lit)`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNegNat","kind":"def","line":325,"name":"Mathlib.Meta.NormNum.Result.isNegNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L325-L329"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">«$α»</span></span>)</span> := by assumption)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">«$x»</span> <span class=\"fn\">«$lit»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"The result is `lit : ℕ` (a raw nat literal) and `proof : isNat x lit`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isNat","kind":"def","line":320,"name":"Mathlib.Meta.NormNum.Result.isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L320-L323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isFalse\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isFalse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">«$x»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\">«$x»</span>)</span></span></div></div>","info":{"doc":"The result is `proof : ¬x`, where `x` is a (false) proposition. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isFalse","kind":"def","line":316,"name":"Mathlib.Meta.NormNum.Result.isFalse","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L316-L318"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">isTrue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\">«$x»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\">«$x»</span>)</span></span></div></div>","info":{"doc":"The result is `proof : x`, where `x` is a (true) proposition. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result.isTrue","kind":"def","line":312,"name":"Mathlib.Meta.NormNum.Result.isTrue","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L312-L314"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instInhabitedResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">x</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult","kind":"instance","line":310,"name":"Mathlib.Meta.NormNum.instInhabitedResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L310-L310"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of `norm_num` running on an expression `x` of type `α`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result","kind":"def","line":307,"name":"Mathlib.Meta.NormNum.Result","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L307-L308"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instInhabitedResult'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'","kind":"instance","line":302,"name":"Mathlib.Meta.NormNum.instInhabitedResult'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L302-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instInhabitedResult'</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instInhabitedResult'.default","kind":"def","line":302,"name":"Mathlib.Meta.NormNum.instInhabitedResult'.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L302-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNegNNRat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNegNNRat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNNRat","kind":"ctor","line":300,"name":"Mathlib.Meta.NormNum.Result'.isNegNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L300-L301"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNNRat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNNRat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNNRat","kind":"ctor","line":298,"name":"Mathlib.Meta.NormNum.Result'.isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L298-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNegNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst </span><span class=\"fn\">lit </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNegNat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNegNat","kind":"ctor","line":296,"name":"Mathlib.Meta.NormNum.Result'.isNegNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L296-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst </span><span class=\"fn\">lit </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isNat`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isNat","kind":"ctor","line":294,"name":"Mathlib.Meta.NormNum.Result'.isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L294-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isBool\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span>.<span class=\"name\">isBool</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">val</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\">Result'</a></div></div>","info":{"doc":"Untyped version of `Result.isBool`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'.isBool","kind":"ctor","line":292,"name":"Mathlib.Meta.NormNum.Result'.isBool","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L292-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of `norm_num` running on an expression `x` of type `α`.\nUntyped version of `Result`. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result'","kind":"inductive","line":289,"name":"Mathlib.Meta.NormNum.Result'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L289-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.den_nz\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">den_nz</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.den_nz","kind":"theorem","line":286,"name":"Mathlib.Meta.NormNum.IsRat.den_nz","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L286-L287"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.den_nz\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">den_nz</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.den_nz","kind":"theorem","line":283,"name":"Mathlib.Meta.NormNum.IsNNRat.den_nz","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L283-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span>)</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.of_raw","kind":"theorem","line":278,"name":"Mathlib.Meta.NormNum.IsRat.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L278-L281"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span>)</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.of_raw","kind":"theorem","line":273,"name":"Mathlib.Meta.NormNum.IsNNRat.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L273-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">n' </span><span class=\"fn\">d'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">d'</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_eq","kind":"theorem","line":269,"name":"Mathlib.Meta.NormNum.IsNNRat.to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L269-L271"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.neg_to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">neg_to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">n' </span><span class=\"fn\">d'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">n'</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">d'</span>)</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.neg_to_eq","kind":"theorem","line":265,"name":"Mathlib.Meta.NormNum.IsRat.neg_to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L265-L267"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_raw_eq","kind":"theorem","line":261,"name":"Mathlib.Meta.NormNum.IsRat.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L261-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_raw_eq","kind":"theorem","line":257,"name":"Mathlib.Meta.NormNum.IsNNRat.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L257-L259"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">to_isRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isRat","kind":"theorem","line":254,"name":"Mathlib.Meta.NormNum.IsInt.to_isRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L254-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">to_isInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isInt","kind":"theorem","line":251,"name":"Mathlib.Meta.NormNum.IsRat.to_isInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L251-L252"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_isRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isRat","kind":"theorem","line":248,"name":"Mathlib.Meta.NormNum.IsNNRat.to_isRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L248-L249"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_isNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isNNRat","kind":"theorem","line":245,"name":"Mathlib.Meta.NormNum.IsNat.to_isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L245-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">to_isNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span> <span class=\"fn\">d</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.to_isNNRat","kind":"theorem","line":242,"name":"Mathlib.Meta.NormNum.IsRat.to_isNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L242-L243"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">to_isNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">1</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.to_isNat","kind":"theorem","line":239,"name":"Mathlib.Meta.NormNum.IsNNRat.to_isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L239-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\"><span class=\"name\">Rat</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw rat cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n* `(NNRat.rawCast n d : α)` where `n` is a raw nat literal, `d` is a raw nat literal, and `d` is not\n  `1` or `0`.\n* `(Rat.rawCast (Int.negOfNat n) d : α)` where `n` is a raw nat literal,\n  `d` is a raw nat literal, `n` is not `0`, and `d` is not `1` or `0`.\n\nThis representation is used by tactics like `ring` to decrease the number of typeclass arguments\nrequired in each use of a number literal at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast","kind":"def","line":223,"name":"Rat.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L223-L237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\"><span class=\"name\">NNRat</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw nnrat cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(NNRat.rawCast n d : α)` where `n` is a raw nat literal, `d` is a raw nat literal, and `d` is not\n  `1` or `0`.\n\nThis representation is used by tactics like `ring` to decrease the number of typeclass arguments\nrequired in each use of a number literal at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast","kind":"def","line":210,"name":"NNRat.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L210-L221"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">num </span><span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inv</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible\">Invertible</a> <span class=\"fn\">↑<span class=\"fn\">denom</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">num</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible.invOf\">⅟</a><span class=\"fn\">↑<span class=\"fn\">denom</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">num</span> <span class=\"fn\">denom</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat.mk","kind":"ctor","line":208,"name":"Mathlib.Meta.NormNum.IsNNRat.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L208-L208"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num </span><span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a semiring is equal to `num / denom`\n(and `denom` is invertible so that this makes sense).\nWe will usually also have `num` and `denom` coprime,\nalthough this is not part of the definition.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat","kind":"inductive","line":201,"name":"Mathlib.Meta.NormNum.IsNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L201-L208"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">num</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inv</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible\">Invertible</a> <span class=\"fn\">↑<span class=\"fn\">denom</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">num</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <a href=\"./Mathlib/Algebra/Group/Invertible/Defs.html#Invertible.invOf\">⅟</a><span class=\"fn\">↑<span class=\"fn\">denom</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">num</span> <span class=\"fn\">denom</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat.mk","kind":"ctor","line":199,"name":"Mathlib.Meta.NormNum.IsRat.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L199-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">num</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">denom</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a ring is equal to `num / denom`\n(and `denom` is invertible so that this makes sense).\nWe will usually also have `num` and `denom` coprime,\nalthough this is not part of the definition.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat","kind":"inductive","line":192,"name":"Mathlib.Meta.NormNum.IsRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L192-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.nonneg_to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">nonneg_to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.nonneg_to_eq","kind":"theorem","line":189,"name":"Mathlib.Meta.NormNum.IsInt.nonneg_to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L189-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.neg_to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">neg_to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a'</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.neg_to_eq","kind":"theorem","line":185,"name":"Mathlib.Meta.NormNum.IsInt.neg_to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L185-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.of_raw","kind":"theorem","line":183,"name":"Mathlib.Meta.NormNum.IsInt.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L183-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_raw_eq","kind":"theorem","line":180,"name":"Mathlib.Meta.NormNum.IsInt.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L180-L181"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_isInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_isInt","kind":"theorem","line":177,"name":"Mathlib.Meta.NormNum.IsNat.to_isInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L177-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">to_isNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.to_isNat","kind":"theorem","line":174,"name":"Mathlib.Meta.NormNum.IsInt.to_isNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L174-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\"><span class=\"name\">Int</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw int cast\" is an expression of the form:\n\n* `(Nat.rawCast lit : α)` where `lit` is a raw natural number literal\n* `(Int.rawCast (Int.negOfNat lit) : α)` where `lit` is a nonzero raw natural number literal\n\n(That is, we only actually use this function for negative integers.) This representation is used by\ntactics like `ring` to decrease the number of typeclass arguments required in each use of a number\nliteral at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast","kind":"def","line":162,"name":"Int.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L162-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.out\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">out</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span></div></div>","info":{"doc":"The element is equal to the coercion of the integer. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.out","kind":"theorem","line":160,"name":"Mathlib.Meta.NormNum.IsInt.out","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L160-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">out</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt.mk","kind":"ctor","line":158,"name":"Mathlib.Meta.NormNum.IsInt.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L158-L158"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsInt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a ring is equal to the coercion of some integer. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt","kind":"structure","line":157,"name":"Mathlib.Meta.NormNum.IsInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L157-L160"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.isNat.natElim\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">isNat</span>.<span class=\"name\">natElim</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">n'</span></span> → <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">n</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.isNat.natElim","kind":"theorem","line":153,"name":"Mathlib.Meta.NormNum.isNat.natElim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L153-L155"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.of_raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">of_raw</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.of_raw","kind":"theorem","line":151,"name":"Mathlib.Meta.NormNum.IsNat.of_raw","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L151-L151"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_raw_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_raw_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_raw_eq","kind":"theorem","line":148,"name":"Mathlib.Meta.NormNum.IsNat.to_raw_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L148-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">to_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.to_eq","kind":"theorem","line":145,"name":"Mathlib.Meta.NormNum.IsNat.to_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L145-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\"><span class=\"name\">Nat</span>.<span class=\"name\">rawCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>","info":{"doc":"A \"raw nat cast\" is an expression of the form `(Nat.rawCast lit : α)` where `lit` is a raw\nnatural number literal. These expressions are used by tactics like `ring` to decrease the number\nof typeclass arguments required in each use of a number literal at type `α`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast","kind":"def","line":138,"name":"Nat.rawCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L138-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.raw_refl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">raw_refl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.raw_refl","kind":"theorem","line":136,"name":"Mathlib.Meta.NormNum.IsNat.raw_refl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L136-L136"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.out\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">out</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span></div></div>","info":{"doc":"The element is equal to the coercion of the natural number. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.out","kind":"theorem","line":134,"name":"Mathlib.Meta.NormNum.IsNat.out","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L134-L134"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">out</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat.mk","kind":"ctor","line":132,"name":"Mathlib.Meta.NormNum.IsNat.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L132-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">IsNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"Assert that an element of a semiring is equal to the coercion of some natural number. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat","kind":"structure","line":131,"name":"Mathlib.Meta.NormNum.IsNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L131-L134"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkOfNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">mkOfNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lit</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">((<span class=\"fn\">a'</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\">↑<span class=\"fn\">«$lit»</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a'»</span>)</span>)</span></span></div></div>","info":{"doc":"Constructs an `ofNat` application `a'` with the canonical instance, together with a proof that\nthe instance is equal to the result of `Nat.cast` on the given `AddMonoidWithOne` instance.\n\nThis function is performance-critical, as many higher level tactics have to construct numerals.\nSo rather than using typeclass search we hardcode the (relatively small) set of solutions\nto the typeclass problem.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkOfNat","kind":"def","line":100,"name":"Mathlib.Meta.NormNum.mkOfNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L100-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.rawIntLitNatAbs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">rawIntLitNatAbs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$n»</span>.<a href=\"./Init/Data/Int/Basic.html#Int.natAbs\">natAbs</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$m»</span>)</span></span></div></div>","info":{"doc":"Extract the raw natlit representing the absolute value of a raw integer literal\n(of the type produced by `Mathlib.Meta.NormNum.mkRawIntLit`) along with an equality proof. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.rawIntLitNatAbs","kind":"def","line":88,"name":"Mathlib.Meta.NormNum.rawIntLitNatAbs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L88-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawRatLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">mkRawRatLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></div></div>","info":{"doc":"Represent an integer as a \"raw\" typed expression.\n\nThis `.lit (.natVal n)` internally to represent a natural number,\nrather than the preferred `OfNat.ofNat` form.\nWe use this internally to avoid unnecessary typeclass searches.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawRatLit","kind":"def","line":76,"name":"Mathlib.Meta.NormNum.mkRawRatLit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L76-L86"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawIntLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">mkRawIntLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></div></div>","info":{"doc":"Represent an integer as a \"raw\" typed expression.\n\nThis uses `.lit (.natVal n)` internally to represent a natural number,\nrather than the preferred `OfNat.ofNat` form.\nWe use this internally to avoid unnecessary typeclass searches.\n\nThis function is the inverse of `Expr.intLit!`.\n","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.mkRawIntLit","kind":"def","line":63,"name":"Mathlib.Meta.NormNum.mkRawIntLit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L63-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferRing\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">inferRing</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"Helper function to synthesize a typed `Ring α` expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferRing","kind":"def","line":59,"name":"Mathlib.Meta.NormNum.inferRing","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L59-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferSemiring\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">inferSemiring</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"Helper function to synthesize a typed `Semiring α` expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferSemiring","kind":"def","line":55,"name":"Mathlib.Meta.NormNum.inferSemiring","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L55-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferAddMonoidWithOne\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">inferAddMonoidWithOne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"Helper function to synthesize a typed `AddMonoidWithOne α` expression. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.inferAddMonoidWithOne","kind":"def","line":50,"name":"Mathlib.Meta.NormNum.inferAddMonoidWithOne","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L50-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAtLeastTwo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAtLeastTwo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">2</span>).<a href=\"./Mathlib/Data/Nat/Init.html#Nat.AtLeastTwo\">AtLeastTwo</a></span></div></div>","info":{"doc":"A shortcut (non)instance for `Nat.AtLeastTwo (n + 2)` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAtLeastTwo","kind":"theorem","line":47,"name":"Mathlib.Meta.NormNum.instAtLeastTwo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L47-L48"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAddMonoidWithOne</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"A shortcut (non)instance for `AddMonoidWithOne α` from `Ring α` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne","kind":"def","line":44,"name":"Mathlib.Meta.NormNum.instAddMonoidWithOne","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L44-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAddMonoidWithOne'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"A shortcut (non)instance for `AddMonoidWithOne α`\nfrom `Semiring α` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOne'","kind":"def","line":40,"name":"Mathlib.Meta.NormNum.instAddMonoidWithOne'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L40-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOneNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">instAddMonoidWithOneNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#AddMonoidWithOne\">AddMonoidWithOne</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"A shortcut (non)instance for `AddMonoidWithOne ℕ` to shrink generated proofs. ","docLink":"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.instAddMonoidWithOneNat","kind":"def","line":37,"name":"Mathlib.Meta.NormNum.instAddMonoidWithOneNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/NormNum/Result.lean#L37-L38"}}],"imports":["Init","Mathlib.Algebra.Field.Defs","Mathlib.Algebra.GroupWithZero.Invertible","Mathlib.Data.Sigma.Basic","Mathlib.Algebra.Ring.Nat","Mathlib.Data.Int.Cast.Basic","Qq.MetaM"],"instances":[{"className":"Inhabited","name":"Mathlib.Meta.NormNum.instInhabitedResult'","typeNames":["Mathlib.Meta.NormNum.Result'"]},{"className":"Inhabited","name":"Mathlib.Meta.NormNum.instInhabitedResult","typeNames":["Mathlib.Meta.NormNum.Result"]},{"className":"Lean.ToMessageData","name":"Mathlib.Meta.NormNum.instToMessageDataResult","typeNames":["Mathlib.Meta.NormNum.Result"]}],"name":"Mathlib.Tactic.NormNum.Result"}
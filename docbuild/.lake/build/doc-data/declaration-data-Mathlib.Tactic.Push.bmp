{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushTree\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabPushTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>","info":{"doc":"`#push_discr_tree X` shows the discrimination tree of all lemmas used by `push X`.\nThis can be helpful when you are constructing a set of `push` lemmas for the constant `X`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabPushTree","kind":"def","line":330,"name":"Mathlib.Tactic.Push.elabPushTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L330-L347"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushTree\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`#push_discr_tree X` shows the discrimination tree of all lemmas used by `push X`.\nThis can be helpful when you are constructing a set of `push` lemmas for the constant `X`.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushTree","kind":"def","line":324,"name":"Mathlib.Tactic.Push.pushTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L324-L328"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#pull head e`, where `head` is a constant and `e` is an expression,\nwhich will print the `pull head` form of `e`.\n\n`#pull` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCommand","kind":"def","line":317,"name":"Mathlib.Tactic.Push.pullCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L317-L318"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPull____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPull____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`pull` is the inverse tactic to `push`.\nIt pulls the given constant towards the head of the expression. For example\n- `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\n- `pull (disch := positivity) Real.log` rewrites `log a + 2 * log b` into `log (a * b ^ 2)`.\n- `pull fun _ ↦ _` rewrites `f ^ 2 + 5` into `fun x => f x ^ 2 + 5` where `f` is a function.\n\nA lemma is considered a `pull` lemma if its reverse direction is a `push` lemma\nthat actually moves the given constant away from the head. For example\n- `not_or : ¬ (p ∨ q) ↔ ¬ p ∧ ¬ q` is a `pull` lemma, but `not_not : ¬ ¬ p ↔ p` is not.\n- `log_mul : log (x * y) = log x + log y` is a `pull` lemma, but `log_abs : log |x| = log x` is not.\n- `Pi.mul_def : f * g = fun (i : ι) => f i * g i` and `Pi.one_def : 1 = fun (x : ι) => 1` are both\n  `pull` lemmas for `fun`, because every `push fun _ ↦ _` lemma is also considered a `pull` lemma.\n\nTODO: define a `@[pull]` attribute for tagging `pull` lemmas that are not `push` lemmas.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPull____","kind":"def","line":305,"name":"Mathlib.Tactic.Push.convPull____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L305-L309"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushNegCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushNegCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#push_neg e`, where `e` is an expression,\nwhich will print the `push_neg` form of `e`.\n\n`#push_neg` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushNegCommand","kind":"def","line":303,"name":"Mathlib.Tactic.Push.pushNegCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L303-L303"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCommand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushCommand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The syntax is `#push head e`, where `head` is a constant and `e` is an expression,\nwhich will print the `push head` form of `e`.\n\n`#push` understands local variables, so you can use them to introduce parameters.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCommand","kind":"def","line":294,"name":"Mathlib.Tactic.Push.pushCommand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L294-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPush_neg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Push negations into the conclusion or a hypothesis.\nFor instance, a hypothesis `h : ¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg at h` into\n`h : ∃ x, ∀ y, y < x`. Binder names are preserved.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`, so that it can preserve binder names, and so that `¬ (p ∧ q)` can be\ntransformed to either `p → ¬ q` (the default) or `¬ p ∨ ¬ q`. To get `¬ p ∨ ¬ q`, use\n`set_option push_neg.use_distrib true`.\n\nAnother example: given a hypothesis\n```lean\nh : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|\n```\nNote that binder names are preserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' ⊢`, as usual.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush_neg","kind":"def","line":286,"name":"Mathlib.Tactic.Push.convPush_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L286-L286"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush____\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">convPush____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push` pushes the given constant away from the head of the expression. For example\n- `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\n- `push (disch := positivity) Real.log` rewrites `log (a * b ^ 2)` into `log a + 2 * log b`.\n- `push ¬ _` is the same as `push_neg` or `push Not`, and it rewrites\n  `¬ ∀ ε > 0, ∃ δ > 0, δ < ε` into `∃ ε > 0, ∀ δ > 0, ε ≤ δ`.\n\nIn addition to constants, `push` can be used to push `fun` and `∀` binders:\n- `push fun _ ↦ _` rewrites `fun x => f x ^ 2 + 5` into `f ^ 2 + 5`\n- `push ∀ _, _` rewrites `∀ a, p a ∧ q a` into `(∀ a, p a) ∧ (∀ a, q a)`.\n\nThe `push` tactic can be extended using the `@[push]` attribute.\n\nTo instead move a constant closer to the head of the expression, use the `pull` tactic.\n\nTo push a constant at a hypothesis, use the `push ... at h` or `push ... at *` syntax.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.convPush____","kind":"def","line":279,"name":"Mathlib.Tactic.Push.convPush____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L279-L283"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#pullFun\"><span class=\"name\">pullFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"A simproc variant of `pull fun _ ↦ _`, to be used as `simp [pullFun]`. ","docLink":"./Mathlib/Tactic/Push.html#pullFun","kind":"def","line":274,"name":"pullFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L274-L275"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#pushFun\"><span class=\"name\">pushFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"A simproc variant of `push fun _ ↦ _`, to be used as `simp [↓pushFun]`. ","docLink":"./Mathlib/Tactic/Push.html#pushFun","kind":"def","line":271,"name":"pushFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L271-L272"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pull</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`pull` is the inverse tactic to `push`.\nIt pulls the given constant towards the head of the expression. For example\n- `pull _ ∈ _` rewrites `x ∈ y ∨ ¬ x ∈ z` into `x ∈ y ∪ zᶜ`.\n- `pull (disch := positivity) Real.log` rewrites `log a + 2 * log b` into `log (a * b ^ 2)`.\n- `pull fun _ ↦ _` rewrites `f ^ 2 + 5` into `fun x => f x ^ 2 + 5` where `f` is a function.\n\nA lemma is considered a `pull` lemma if its reverse direction is a `push` lemma\nthat actually moves the given constant away from the head. For example\n- `not_or : ¬ (p ∨ q) ↔ ¬ p ∧ ¬ q` is a `pull` lemma, but `not_not : ¬ ¬ p ↔ p` is not.\n- `log_mul : log (x * y) = log x + log y` is a `pull` lemma, but `log_abs : log |x| = log x` is not.\n- `Pi.mul_def : f * g = fun (i : ι) => f i * g i` and `Pi.one_def : 1 = fun (x : ι) => 1` are both\n  `pull` lemmas for `fun`, because every `push fun _ ↦ _` lemma is also considered a `pull` lemma.\n\nTODO: define a `@[pull]` attribute for tagging `pull` lemmas that are not `push` lemmas.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pull","kind":"def","line":248,"name":"Mathlib.Tactic.Push.pull","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L248-L269"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push_neg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Push negations into the conclusion or a hypothesis.\nFor instance, a hypothesis `h : ¬ ∀ x, ∃ y, x ≤ y` will be transformed by `push_neg at h` into\n`h : ∃ x, ∀ y, y < x`. Binder names are preserved.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`, so that it can preserve binder names, and so that `¬ (p ∧ q)` can be\ntransformed to either `p → ¬ q` (the default) or `¬ p ∨ ¬ q`. To get `¬ p ∨ ¬ q`, use\n`set_option push_neg.use_distrib true`.\n\nAnother example: given a hypothesis\n```lean\nh : ¬ ∀ ε > 0, ∃ δ > 0, ∀ x, |x - x₀| ≤ δ → |f x - y₀| ≤ ε\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : ∃ ε > 0, ∀ δ > 0, ∃ x, |x - x₀| ≤ δ ∧ ε < |f x - y₀|\n```\nNote that binder names are preserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' ⊢`, as usual.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg","kind":"def","line":246,"name":"Mathlib.Tactic.Push.push_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L246-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`push` pushes the given constant away from the head of the expression. For example\n- `push _ ∈ _` rewrites `x ∈ {y} ∪ zᶜ` into `x = y ∨ ¬ x ∈ z`.\n- `push (disch := positivity) Real.log` rewrites `log (a * b ^ 2)` into `log a + 2 * log b`.\n- `push ¬ _` is the same as `push_neg` or `push Not`, and it rewrites\n  `¬ ∀ ε > 0, ∃ δ > 0, δ < ε` into `∃ ε > 0, ∀ δ > 0, ε ≤ δ`.\n\nIn addition to constants, `push` can be used to push `fun` and `∀` binders:\n- `push fun _ ↦ _` rewrites `fun x => f x ^ 2 + 5` into `f ^ 2 + 5`\n- `push ∀ _, _` rewrites `∀ a, p a ∧ q a` into `(∀ a, p a) ∧ (∀ a, q a)`.\n\nThe `push` tactic can be extended using the `@[push]` attribute.\n\nTo instead move a constant closer to the head of the expression, use the `pull` tactic.\n\nTo push a constant at a hypothesis, use the `push ... at h` or `push ... at *` syntax.\n","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push","kind":"def","line":198,"name":"Mathlib.Tactic.Push.push","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L198-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabDischarger\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabDischarger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.discharger</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span></div></div>","info":{"doc":"Elaborate the `(disch := ...)` syntax for a `simp`-like tactic. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabDischarger","kind":"def","line":194,"name":"Mathlib.Tactic.Push.elabDischarger","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L194-L196"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabHead\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">elabHead</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a></span></div></div>","info":{"doc":"Elaborator for the argument passed to `push`. It accepts a constant, or a function ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.elabHead","kind":"def","line":176,"name":"Mathlib.Tactic.Push.elabHead","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L176-L190"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.resolvePushId?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">resolvePushId?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">stx</span> : <a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"`resolvePushId?` is a version of `resolveId?` that also supports notations like `_ ∈ _`,\n`∃ x, _` and `∑ x, _`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.resolvePushId?","kind":"def","line":154,"name":"Mathlib.Tactic.Push.resolvePushId?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L154-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.isUnderscore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">isUnderscore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Meta/Defs.html#Lean.Syntax.Term\">Lean.Term</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Return `true` if `stx` is an underscore, i.e. `_` or `fun $_ => _`/`fun $_ ↦ _`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.isUnderscore","kind":"def","line":149,"name":"Mathlib.Tactic.Push.isUnderscore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L149-L152"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Common entry point to the implementation of `pull`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullCore","kind":"def","line":136,"name":"Mathlib.Tactic.Push.pullCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L136-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pullStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Try to rewrite using a `pull` lemma. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pullStep","kind":"def","line":121,"name":"Mathlib.Tactic.Push.pullStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L121-L134"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tgt</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">disch?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Rewrite.html#Lean.Meta.Simp.Discharge\">Lean.Meta.Simp.Discharge</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Common entry point to the implementation of `push`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushCore","kind":"def","line":111,"name":"Mathlib.Tactic.Push.pushCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L111-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">head</span> : <a href=\"./Mathlib/Tactic/Push/Attr.html#Mathlib.Tactic.Push.Head\">Head</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Try to rewrite using a `push` lemma. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushStep","kind":"def","line":95,"name":"Mathlib.Tactic.Push.pushStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L95-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushSimpConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">pushSimpConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.Simp.Config\">Lean.Meta.Simp.Config</a></div></div>","info":{"doc":"The `simp` configuration used in `push`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.pushSimpConfig","kind":"def","line":90,"name":"Mathlib.Tactic.Push.pushSimpConfig","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L90-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg.use_distrib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">push_neg</span>.<span class=\"name\">use_distrib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Make `push_neg` use `not_and_or` rather than the default `not_and`. ","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.push_neg.use_distrib","kind":"opaque","line":58,"name":"Mathlib.Tactic.Push.push_neg.use_distrib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L58-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_forall_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_forall_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">α</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_forall_eq","kind":"theorem","line":56,"name":"Mathlib.Tactic.Push.not_forall_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L56-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_or_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_and_or_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span>)) <a href=\"./Init/Prelude.html#Eq\">=</a> (<a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span>)</div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_or_eq","kind":"theorem","line":55,"name":"Mathlib.Tactic.Push.not_and_or_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L55-L55"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_and_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span>)) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">(<span class=\"fn\">p</span> → <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span>)</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_and_eq","kind":"theorem","line":54,"name":"Mathlib.Tactic.Push.not_and_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L54-L54"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_exists\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_exists</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\">(<a href=\"./Init/Prelude.html#Not\">¬</a><a href=\"./Init/Core.html#Exists\">∃</a> <a href=\"./Init/Core.html#Exists\">(</a><span class=\"fn\">x</span> <a href=\"./Init/Core.html#Exists\">:</a> <span class=\"fn\">α</span><a href=\"./Init/Core.html#Exists\">)</a><a href=\"./Init/Core.html#Exists\">,</a> <span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span>) <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\"><a href=\"./Init/BinderNameHint.html#binderNameHint\">binderNameHint</a> <span class=\"fn\">x</span> <span class=\"fn\">s</span> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">s</span> <span class=\"fn\">x</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_exists","kind":"theorem","line":33,"name":"Mathlib.Tactic.Push.not_exists","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L33-L34"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Push</span>.<span class=\"name\">not_iff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./foundational_types.html\">Prop</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Not\">¬</a>(<span class=\"fn\">p</span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">q</span>) <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">q</span> <a href=\"./Init/Prelude.html#Or\">∨</a> <a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\">p</span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\">q</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Push.html#Mathlib.Tactic.Push.not_iff","kind":"theorem","line":31,"name":"Mathlib.Tactic.Push.not_iff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Push.lean#L31-L32"}}],"imports":["Init","Lean.Elab.Tactic.Location","Mathlib.Tactic.Push.Attr","Mathlib.Logic.Basic","Mathlib.Tactic.Conv","Mathlib.Util.AtLocation"],"instances":[],"name":"Mathlib.Tactic.Push"}
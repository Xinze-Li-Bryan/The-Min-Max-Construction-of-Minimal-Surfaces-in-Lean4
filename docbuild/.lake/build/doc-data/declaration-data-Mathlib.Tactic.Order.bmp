{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">tacticOrder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A finishing tactic for solving goals in arbitrary `Preorder`, `PartialOrder`,\nor `LinearOrder`. Supports `⊤`, `⊥`, and lattice operations. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.tacticOrder","kind":"def","line":243,"name":"Mathlib.Tactic.Order.tacticOrder","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L243-L275"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">instOrdProdNatExpr_mathlib</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord/Basic.html#Ord\">Ord</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Necessary for tracing below. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib","kind":"def","line":239,"name":"Mathlib.Tactic.Order.instOrdProdNatExpr_mathlib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L239-L241"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findBestOrderInstance\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findBestOrderInstance</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a>)</span></span></div></div>","info":{"doc":"Find the \"best\" instance of an order on a given type. A linear order is preferred over a partial\norder, and a partial order is preferred over a preorder. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findBestOrderInstance","kind":"def","line":228,"name":"Mathlib.Tactic.Order.findBestOrderInstance","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L228-L237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instToStringOrderType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">instToStringOrderType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instToStringOrderType","kind":"instance","line":222,"name":"Mathlib.Tactic.Order.instToStringOrderType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L222-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">instBEqOrderType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType","kind":"instance","line":220,"name":"Mathlib.Tactic.Order.instBEqOrderType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L220-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType.beq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">instBEqOrderType</span>.<span class=\"name\">beq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a> → <a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.instBEqOrderType.beq","kind":"def","line":220,"name":"Mathlib.Tactic.Order.instBEqOrderType.beq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L220-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.pre\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">OrderType</span>.<span class=\"name\">pre</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.pre","kind":"ctor","line":219,"name":"Mathlib.Tactic.Order.OrderType.pre","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L219-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.part\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">OrderType</span>.<span class=\"name\">part</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.part","kind":"ctor","line":219,"name":"Mathlib.Tactic.Order.OrderType.part","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L219-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.lin\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">OrderType</span>.<span class=\"name\">lin</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\">OrderType</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType.lin","kind":"ctor","line":219,"name":"Mathlib.Tactic.Order.OrderType.lin","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L219-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">OrderType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Supported order types: linear, partial, and preorder. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.OrderType","kind":"inductive","line":217,"name":"Mathlib.Tactic.Order.OrderType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L217-L220"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">updateGraphWithNltInfSup</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">idxToAtom</span> : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a></span></div></div>","info":{"doc":"Adds edges to the `≤`-graph using two types of facts:\n1. Each fact `¬ (x < y)` allows to add the edge `(x, y)` when `y` is reachable from `x` in the\ngraph.\n2. Each fact `x ⊔ y = z` allows to add the edge `(z, s)` when `s` is reachable from both `x`\nand `y`.\n\nWe repeat the process until no more edges can be added. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.updateGraphWithNltInfSup","kind":"def","line":174,"name":"Mathlib.Tactic.Order.updateGraphWithNltInfSup","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L174-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findContradictionWithNle</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">idxToAtom</span> : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Using the `≤`-graph `g`, find a contradiction with some `≰`-fact. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNle","kind":"def","line":165,"name":"Mathlib.Tactic.Order.findContradictionWithNle","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L165-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Order</span>.<span class=\"name\">findContradictionWithNe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">graph</span> : <a href=\"./Mathlib/Tactic/Order/Graph/Basic.html#Mathlib.Tactic.Order.Graph\">Graph</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">idxToAtom</span> : <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">facts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/Order/CollectFacts.html#Mathlib.Tactic.Order.AtomicFact\">AtomicFact</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Finds a contradictory `≠`-fact whose `.lhs` and `.rhs` belong to the same strongly connected\ncomponent in the `≤`-graph, implying they must be equal, and then uses it to derive `False`. ","docLink":"./Mathlib/Tactic/Order.html#Mathlib.Tactic.Order.findContradictionWithNe","kind":"def","line":148,"name":"Mathlib.Tactic.Order.findContradictionWithNe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/Order.lean#L148-L163"}}],"imports":["Init","Mathlib.Tactic.Order.CollectFacts","Mathlib.Tactic.Order.Preprocessing","Mathlib.Tactic.Order.Graph.Basic","Mathlib.Tactic.Order.Graph.Tarjan"],"instances":[{"className":"BEq","name":"Mathlib.Tactic.Order.instBEqOrderType","typeNames":["Mathlib.Tactic.Order.OrderType"]},{"className":"ToString","name":"Mathlib.Tactic.Order.instToStringOrderType","typeNames":["Mathlib.Tactic.Order.OrderType"]}],"name":"Mathlib.Tactic.Order"}
{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_struct</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct","kind":"def","line":335,"name":"Mathlib.Tactic.convEta_struct","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L335-L336"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx","kind":"def","line":322,"name":"Mathlib.Tactic.etaStructStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L322-L333"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Finds all occurrences of expressions of the form `S.mk x.1 ... x.n` where `S.mk`\nis a structure constructor and replaces them by `x`. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll","kind":"def","line":313,"name":"Mathlib.Tactic.etaStructAll","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L313-L320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?.findProj\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span>.<span class=\"name\">findProj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fVal</span> : <a href=\"./Lean/Declaration.html#Lean.ConstructorVal\">Lean.ConstructorVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Lean/Data/LOption.html#Lean.LOption\">Lean.LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Check to see if there's an argument at some index `i`\nsuch that it's the `i`th projection of a some expression.\nReturns the expression. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?.findProj","kind":"def","line":301,"name":"Mathlib.Tactic.etaStruct?.findProj","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L301-L311"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tryWhnfR</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Checks if the expression is of the form `S.mk x.1 ... x.n` with `n` nonzero\nand `S.mk` a structure constructor and returns `x`.\nEach projection `x.i` can be either a native projection or from a projection function.\n\n`tryWhnfR` controls whether to try applying `whnfR` to arguments when none of them\nare obviously projections.\n\nOnce an obviously correct projection is found, relies on the structure eta rule in `isDefEq`. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?","kind":"def","line":274,"name":"Mathlib.Tactic.etaStruct?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L274-L311"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getProjectedExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>))</span></span></div></div>","info":{"doc":"Given an expression that's either a native projection or a registered projection\nfunction, gives (1) the name of the structure type, (2) the index of the projection, and\n(3) the object being projected. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr","kind":"def","line":261,"name":"Mathlib.Tactic.getProjectedExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L261-L272"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_expand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand","kind":"def","line":255,"name":"Mathlib.Tactic.convEta_expand","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L255-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx","kind":"def","line":241,"name":"Mathlib.Tactic.etaExpandStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L241-L253"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Eta expand every sub-expression in the given expression.\n\nAs a side-effect, beta reduces any pre-existing instances of eta expanded terms. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll","kind":"opaque","line":219,"name":"Mathlib.Tactic.etaExpandAll","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L219-L239"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce","kind":"def","line":213,"name":"Mathlib.Tactic.convEta_reduce","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L213-L214"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx","kind":"def","line":204,"name":"Mathlib.Tactic.etaReduceStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L204-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Eta reduce everything ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll","kind":"def","line":197,"name":"Mathlib.Tactic.etaReduceAll","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L197-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convUnfold_projs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs","kind":"def","line":191,"name":"Mathlib.Tactic.convUnfold_projs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L191-L192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjsStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx","kind":"def","line":184,"name":"Mathlib.Tactic.unfoldProjsStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L184-L189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Recursively unfold all the projection applications for class instances. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs","kind":"def","line":176,"name":"Mathlib.Tactic.unfoldProjs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L176-L182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convRefold_let___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convRefold_let___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`refold_let x y z at loc` looks for the bodies of local definitions `x`, `y`, and `z` at the given\nlocation and replaces them with `x`, `y`, or `z`. This is the inverse of \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convRefold_let___","kind":"def","line":166,"name":"Mathlib.Tactic.convRefold_let___","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L166-L167"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refoldLetStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`refold_let x y z at loc` looks for the bodies of local definitions `x`, `y`, and `z` at the given\nlocation and replaces them with `x`, `y`, or `z`. This is the inverse of \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldLetStx","kind":"def","line":153,"name":"Mathlib.Tactic.refoldLetStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L153-L159"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">refoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"For each fvar, looks for its body in `e` and replaces it with the fvar. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.refoldFVars","kind":"def","line":135,"name":"Mathlib.Tactic.refoldFVars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L135-L151"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvars</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Unfold all the fvars from `fvars` in `e` that have local definitions (are \"let-bound\"). ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars","kind":"def","line":119,"name":"Mathlib.Tactic.unfoldFVars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L119-L131"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticReduce__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`reduce at loc` completely reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis does the same transformation as the `#reduce` command.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__","kind":"def","line":107,"name":"Mathlib.Tactic.tacticReduce__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L107-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convBeta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce","kind":"def","line":101,"name":"Mathlib.Tactic.convBeta_reduce","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L101-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">betaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx","kind":"def","line":90,"name":"Mathlib.Tactic.betaReduceStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L90-L99"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticWhnf__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`whnf at loc` puts the given location into weak-head normal form.\nThis also exists as a `conv`-mode tactic.\n\nWeak-head normal form is when the outer-most expression has been fully reduced, the expression\nmay contain subexpressions which have not been reduced.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__","kind":"def","line":77,"name":"Mathlib.Tactic.tacticWhnf__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L77-L85"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqConvTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Like `Mathlib.Tactic.runDefEqTactic` but for `conv` mode. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic","kind":"def","line":70,"name":"Mathlib.Tactic.runDefEqConvTactic","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L70-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">loc?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.location</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tacticName</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"For the main goal, use `m` to transform the types of locations specified by `loc?`.\nIf `loc?` is none, then transforms the type of target. `m` is provided with an expression\nwith instantiated metavariables as well as, if the location is a local hypothesis, the fvar.\n\n`m` *must* transform expressions to defeq expressions.\nIf `checkDefEq = true` (the default) then `runDefEqTactic` will throw an error\nif the resulting expression is not definitionally equal to the original expression. ","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic","kind":"def","line":45,"name":"Mathlib.Tactic.runDefEqTactic","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L45-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Lean.MVarId.changeLocalDecl'\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">changeLocalDecl'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mvarId</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fvarId</span> : <a href=\"./Lean/Expr.html#Lean.FVarId\">FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">typeNew</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">checkDefEq</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">MVarId</a></span></div></div>","info":{"doc":"This is `Lean.MVarId.changeLocalDecl` but makes sure to preserve local variable order.\n","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Lean.MVarId.changeLocalDecl'","kind":"def","line":20,"name":"Lean.MVarId.changeLocalDecl'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/d3298500e6d853c0856bebdb79d46f430b6a5e5e/Mathlib/Tactic/DefEqTransformations.lean#L20-L43"}}],"imports":["Init","Mathlib.Tactic.Basic"],"instances":[],"name":"Mathlib.Tactic.DefEqTransformations"}
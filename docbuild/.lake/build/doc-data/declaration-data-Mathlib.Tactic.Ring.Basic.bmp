{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">tacticRing1!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for solving equations of *commutative* (semi)rings,\nallowing variables in the exponent.\n\n* This version of `ring` fails if the target is not an equality.\n* The variant `ring1!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.tacticRing1!","kind":"def","line":1410,"name":"Mathlib.Tactic.Ring.tacticRing1!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1410-L1410"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ring1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Tactic for solving equations of *commutative* (semi)rings,\nallowing variables in the exponent.\n\n* This version of `ring` fails if the target is not an equality.\n* The variant `ring1!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ring1","kind":"def","line":1399,"name":"Mathlib.Tactic.Ring.ring1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1399-L1408"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq.ringCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">proveEq</span>.<span class=\"name\">ringCore</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">Q(<span class=\"fn\">«$e₁»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e₂»</span>)</span></span></div></div>","info":{"doc":"The core of `proveEq` takes expressions `e₁ e₂ : α` where `α` is a `CommSemiring`,\nand returns a proof that they are equal (or fails). ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq.ringCore","kind":"def","line":1387,"name":"Mathlib.Tactic.Ring.proveEq.ringCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1387-L1397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">proveEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Frontend of `ring1`: attempt to close a goal `g`, assuming it is an equation of semirings. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.proveEq","kind":"def","line":1358,"name":"Mathlib.Tactic.Ring.proveEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1358-L1397"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ringCleanupRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <span class=\"fn\">(<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>","info":{"doc":"This is a routine which is used to clean up the unsolved subgoal\nof a failed `ring1` application. It is overridden in `Mathlib/Tactic/Ring/RingNF.lean`\nto apply the `ring_nf` simp set to the goal.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ringCleanupRef","kind":"opaque","line":1351,"name":"Mathlib.Tactic.Ring.ringCleanupRef","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1351-L1356"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">of_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_eq","kind":"theorem","line":1349,"name":"Mathlib.Tactic.Ring.of_eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1349-L1349"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_lift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">of_lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b'</span> : <span class=\"fn\">β</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">h1</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">a'</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">h2</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">b</span> <span class=\"fn\">b'</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.of_lift","kind":"theorem","line":1343,"name":"Mathlib.Tactic.Ring.of_lift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1343-L1345"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCSLiftValLift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instCSLiftValLift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α </span><span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">CSLift.lift</a> <span class=\"fn\">a</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCSLiftValLift","kind":"instance","line":1341,"name":"Mathlib.Tactic.Ring.instCSLiftValLift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1341-L1341"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLiftVal</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">inst✝</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">CSLift.lift</a> <span class=\"fn\">a</span></span></div></div>","info":{"doc":"The output value `b` is equal to the lift of `a`. This can be supplied by the default\ninstance which sets `b := lift a`, but `ring` will treat this as an atom so it is more useful\nwhen there are other instances which distribute addition or multiplication. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.eq","kind":"theorem","line":1339,"name":"Mathlib.Tactic.Ring.CSLiftVal.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1339-L1339"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLiftVal</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">CSLift.lift</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\">CSLiftVal</a> <span class=\"fn\">a</span> <span class=\"fn\">b</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal.mk","kind":"ctor","line":1335,"name":"Mathlib.Tactic.Ring.CSLiftVal.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1335-L1335"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLiftVal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"`CSLiftVal a b` means that `b = lift a`. This is used by `ring` to construct an expression `b`\nfrom the input expression `a`, and then run the usual ring algorithm on `b`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLiftVal","kind":"class","line":1333,"name":"Mathlib.Tactic.Ring.CSLiftVal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1333-L1339"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.inj\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span>.<span class=\"name\">inj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Injective\">Function.Injective</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\">lift</a></span></div></div>","info":{"doc":"`lift` is an injective function ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.inj","kind":"theorem","line":1331,"name":"Mathlib.Tactic.Ring.CSLift.inj","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1331-L1331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span>.<span class=\"name\">lift</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span></div></div>","info":{"doc":"`lift` is the \"canonical injection\" from `α` to `β` ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.lift","kind":"def","line":1329,"name":"Mathlib.Tactic.Ring.CSLift.lift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1329-L1329"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lift</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inj</span> : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">lift</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\">CSLift</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift.mk","kind":"ctor","line":1327,"name":"Mathlib.Tactic.Ring.CSLift.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1327-L1327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">class</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">CSLift</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">β</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#outParam\">outParam</a> <a href=\"./foundational_types.html\">(Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"`CSLift α β` is a typeclass used by `ring` for lifting operations from `α`\n(which is not a commutative semiring) into a commutative semiring `β` by using an injective map\n`lift : α → β`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.CSLift","kind":"class","line":1324,"name":"Mathlib.Tactic.Ring.CSLift","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1324-L1331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Evaluates expression `e` of type `α` into a normalized representation as a polynomial.\nThis is the main driver of `ring`, which calls out to `evalAdd`, `evalMul` etc.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.eval","kind":"opaque","line":1247,"name":"Mathlib.Tactic.Ring.eval","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1247-L1320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">isAtomOrDerivable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span>)</span>)</span></span></div></div>","info":{"doc":"Checks whether `e` would be processed by `eval` as a ring expression,\nor otherwise if it is an atom or something simplifiable via `norm_num`.\n\nWe use this in `ring_nf` to avoid rewriting atoms unnecessarily.\n\nReturns:\n* `none` if `eval` would process `e` as an algebraic ring expression\n* `some none` if `eval` would treat `e` as an atom.\n* `some (some r)` if `eval` would not process `e` as an algebraic ring expression,\n  but `NormNum.derive` can nevertheless simplify `e`, with result `r`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.isAtomOrDerivable","kind":"def","line":1218,"name":"Mathlib.Tactic.Ring.isAtomOrDerivable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1218-L1245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">int</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a></span></div></div>","info":{"doc":"A precomputed `Cache` for `ℤ`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.int","kind":"def","line":1214,"name":"Mathlib.Tactic.Ring.Cache.int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1214-L1216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">nat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a></span></div></div>","info":{"doc":"A precomputed `Cache` for `ℕ`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.nat","kind":"def","line":1211,"name":"Mathlib.Tactic.Ring.Cache.nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1211-L1212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">div_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_congr","kind":"theorem","line":1208,"name":"Mathlib.Tactic.Ring.div_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1208-L1209"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">a'</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_congr","kind":"theorem","line":1205,"name":"Mathlib.Tactic.Ring.inv_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1205-L1206"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sub_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_congr","kind":"theorem","line":1202,"name":"Mathlib.Tactic.Ring.sub_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1202-L1203"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_congr","kind":"theorem","line":1199,"name":"Mathlib.Tactic.Ring.neg_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1199-L1200"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">b'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_congr","kind":"theorem","line":1196,"name":"Mathlib.Tactic.Ring.pow_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1196-L1197"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zsmul_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">zsmul_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zsmul_congr","kind":"theorem","line":1191,"name":"Mathlib.Tactic.Ring.zsmul_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1191-L1194"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">nsmul_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.nsmul_congr","kind":"theorem","line":1187,"name":"Mathlib.Tactic.Ring.nsmul_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1187-L1189"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_congr","kind":"theorem","line":1184,"name":"Mathlib.Tactic.Ring.mul_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1184-L1185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_congr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b'</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_congr","kind":"theorem","line":1181,"name":"Mathlib.Tactic.Ring.add_congr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1181-L1182"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalDiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Divides two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a / b = a * b⁻¹`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalDiv","kind":"def","line":1171,"name":"Mathlib.Tactic.Ring.evalDiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1171-L1179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">div_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">b</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.div_pf","kind":"theorem","line":1167,"name":"Mathlib.Tactic.Ring.div_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1167-L1169"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a>)</span>)</span></span></div></div>","info":{"doc":"Inverts a polynomial `va` to get a normalized result polynomial.\n\n* `0⁻¹ = 0`\n* `a⁻¹ = (a⁻¹)` if `a` is a nontrivial sum\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalInv","kind":"def","line":1149,"name":"Mathlib.Tactic.Ring.ExSum.evalInv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1149-L1163"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalInv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a>)</span>)</span></span></div></div>","info":{"doc":"Inverts a polynomial `va` to get a normalized result polynomial.\n\n* `c⁻¹ = (c⁻¹)` if `c` is a constant\n* `(a ^ b * c)⁻¹ = a⁻¹ ^ b * c⁻¹`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalInv","kind":"def","line":1123,"name":"Mathlib.Tactic.Ring.ExProd.evalInv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1123-L1147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalInvAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a>)</span>)</span></span></div></div>","info":{"doc":"Applies `⁻¹` to a polynomial to get an atom. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalInvAtom","kind":"def","line":1118,"name":"Mathlib.Tactic.Ring.evalInvAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1118-L1121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_add","kind":"theorem","line":1110,"name":"Mathlib.Tactic.Ring.inv_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1110-L1112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_single</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>)<a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_single","kind":"theorem","line":1108,"name":"Mathlib.Tactic.Ring.inv_single","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1108-L1109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_zero","kind":"theorem","line":1106,"name":"Mathlib.Tactic.Ring.inv_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1106-L1106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">inv_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₃ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₁</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">a₃</span><a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₃</span> → <span class=\"fn\"><span class=\"fn\">b₃</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → (<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>)<a href=\"./Init/Prelude.html#Inv.inv\">⁻¹</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.inv_mul","kind":"theorem","line":1101,"name":"Mathlib.Tactic.Ring.inv_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1101-L1104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Evaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAtom","kind":"def","line":1087,"name":"Mathlib.Tactic.Ring.evalAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1087-L1099"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">atom_pf'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf'","kind":"theorem","line":1084,"name":"Mathlib.Tactic.Ring.atom_pf'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1084-L1085"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">atom_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.atom_pf","kind":"theorem","line":1083,"name":"Mathlib.Tactic.Ring.atom_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1083-L1083"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">toProd_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">a'</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.toProd_pf","kind":"theorem","line":1081,"name":"Mathlib.Tactic.Ring.toProd_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1081-L1082"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Meta.NormNum.Result</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span>)</span></span></span></div></div>","info":{"doc":"Converts a proof by `norm_num` that `e` is a numeral, into a normalization as a monomial:\n\n* `e = 0` if `norm_num` returns `IsNat e 0`\n* `e = Nat.rawCast n + 0` if `norm_num` returns `IsNat e n`\n* `e = Int.rawCast n + 0` if `norm_num` returns `IsInt e n`\n* `e = NNRat.rawCast n d + 0` if `norm_num` returns `IsNNRat e n d`\n* `e = Rat.rawCast n d + 0` if `norm_num` returns `IsRat e n d`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalCast","kind":"def","line":1055,"name":"Mathlib.Tactic.Ring.evalCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1055-L1079"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_rat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsRat\">Meta.NormNum.IsRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_rat","kind":"theorem","line":1051,"name":"Mathlib.Tactic.Ring.cast_rat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1051-L1053"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_nnrat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_nnrat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">d</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNNRat\">Meta.NormNum.IsNNRat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#NNRat.rawCast\">NNRat.rawCast</a> <span class=\"fn\">n</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_nnrat","kind":"theorem","line":1047,"name":"Mathlib.Tactic.Ring.cast_nnrat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1047-L1049"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Meta.NormNum.IsInt</a> <span class=\"fn\">a</span> <span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_neg","kind":"theorem","line":1043,"name":"Mathlib.Tactic.Ring.cast_neg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1043-L1045"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">0</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_zero","kind":"theorem","line":1040,"name":"Mathlib.Tactic.Ring.cast_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1040-L1041"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">cast_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">n</span></span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.cast_pos","kind":"theorem","line":1037,"name":"Mathlib.Tactic.Ring.cast_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1037-L1038"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mkCache</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span>)</span></span></div></div>","info":{"doc":"Create a new cache for `α` by doing the necessary instance searches. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mkCache","kind":"def","line":1030,"name":"Mathlib.Tactic.Ring.mkCache","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1030-L1035"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.czα\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">czα</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"A characteristic zero ring instance on `α`, if available. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.czα","kind":"def","line":1028,"name":"Mathlib.Tactic.Ring.Cache.czα","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1028-L1028"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.dsα\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">dsα</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"A division semiring instance on `α`, if available. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.dsα","kind":"def","line":1026,"name":"Mathlib.Tactic.Ring.Cache.dsα","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1026-L1026"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.rα\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">rα</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span></span></div></div>","info":{"doc":"A ring instance on `α`, if available. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.rα","kind":"def","line":1024,"name":"Mathlib.Tactic.Ring.Cache.rα","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1024-L1024"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">dsα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">czα</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharZero/Defs.html#CharZero\">CharZero</a> <span class=\"fn\">«$α»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\">Cache</a> <span class=\"fn\">sα</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache.mk","kind":"ctor","line":1022,"name":"Mathlib.Tactic.Ring.Cache.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1022-L1022"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Cache</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"This cache contains data required by the `ring` tactic during execution. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Cache","kind":"structure","line":1021,"name":"Mathlib.Tactic.Ring.Cache","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1021-L1028"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Exponentiates two polynomials `va, vb`.\n\n* `a ^ 0 = 1`\n* `a ^ (b₁ + b₂) = a ^ b₁ * a ^ b₂`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow","kind":"def","line":1006,"name":"Mathlib.Tactic.Ring.evalPow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1006-L1019"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\"><span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_add","kind":"theorem","line":1002,"name":"Mathlib.Tactic.Ring.pow_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1002-L1004"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_zero","kind":"theorem","line":1000,"name":"Mathlib.Tactic.Ring.pow_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L1000-L1000"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPow₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Exponentiates a polynomial `va` by a monomial `vb`, including several special cases.\n\n* `a ^ 1 = a`\n* `0 ^ e = 0` if `0 < e`\n* `(a + 0) ^ b = a ^ b` computed using `evalPowProd`\n* `a ^ b = (a ^ b') ^ k` if `b = b' * k` and `k > 1`\n\nOtherwise `a ^ b` is just encoded as `a ^ b * 1 + 0` using `evalPowAtom`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPow₁","kind":"opaque","line":970,"name":"Mathlib.Tactic.Ring.evalPow₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L970-L998"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_nat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d </span><span class=\"fn\">e</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\"><span class=\"fn\">d</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">e</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_nat","kind":"theorem","line":966,"name":"Mathlib.Tactic.Ring.pow_nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L966-L968"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">single_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.single_pow","kind":"theorem","line":963,"name":"Mathlib.Tactic.Ring.single_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L963-L964"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">zero_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">b</span> → <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_pow","kind":"theorem","line":961,"name":"Mathlib.Tactic.Ring.zero_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L961-L961"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_one_cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one_cast","kind":"theorem","line":959,"name":"Mathlib.Tactic.Ring.pow_one_cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L959-L959"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">extractCoeff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">a</span></span></div></div>","info":{"doc":"Given a monomial expression `va`, splits off the leading coefficient `k` and the remainder\n`e'`, stored in the `ExtractCoeff` structure.\n\n* `c = 1 * c` (if `c` is a constant)\n* `a * b = (a * b') * k` if `b = b' * k`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.extractCoeff","kind":"def","line":944,"name":"Mathlib.Tactic.Ring.extractCoeff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L944-L957"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">coeff_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">c₂ </span><span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_mul","kind":"theorem","line":940,"name":"Mathlib.Tactic.Ring.coeff_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L940-L942"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">coeff_one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">k</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">k</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.coeff_one","kind":"theorem","line":938,"name":"Mathlib.Tactic.Ring.coeff_one","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L938-L938"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.p\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">p</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">unknown_1</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">unknown_2</span>)</span></div></div>","info":{"doc":"The proof that `e` splits into the coefficient `k` and the monic monomial `e'`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.p","kind":"def","line":936,"name":"Mathlib.Tactic.Ring.ExtractCoeff.p","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L936-L936"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.ve'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">ve'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'\">e'</a></span></span></div></div>","info":{"doc":"`e'` is a monomial. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.ve'","kind":"def","line":934,"name":"Mathlib.Tactic.Ring.ExtractCoeff.ve'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L934-L934"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">e'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>","info":{"doc":"The result of extracting the coefficient is a monic monomial. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.e'","kind":"def","line":932,"name":"Mathlib.Tactic.Ring.ExtractCoeff.e'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L932-L932"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">k</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>","info":{"doc":"A raw natural number literal. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.k","kind":"def","line":930,"name":"Mathlib.Tactic.Ring.ExtractCoeff.k","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L930-L930"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k </span><span class=\"fn\">e'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ve'</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">e'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$e'»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$k»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\">ExtractCoeff</a> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff.mk","kind":"ctor","line":928,"name":"Mathlib.Tactic.Ring.ExtractCoeff.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L928-L928"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExtractCoeff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of `extractCoeff` is a numeral and a proof that the original expression\nfactors by this numeral.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExtractCoeff","kind":"structure","line":924,"name":"Mathlib.Tactic.Ring.ExtractCoeff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L924-L936"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"There are several special cases when exponentiating monomials:\n\n* `1 ^ n = 1`\n* `x ^ y = (x ^ y)` when `x` and `y` are constants\n* `(a * b) ^ e = a ^ e * b ^ e`\n\nIn all other cases we use `evalPowProdAtom`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProd","kind":"def","line":893,"name":"Mathlib.Tactic.Ring.evalPowProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L893-L922"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂ </span><span class=\"fn\">c₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">ea₁ </span><span class=\"fn\">b </span><span class=\"fn\">c₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">xa₁</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">ea₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → (<span class=\"fn\">xa₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">ea₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₂</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">xa₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pow","kind":"theorem","line":889,"name":"Mathlib.Tactic.Ring.mul_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L889-L891"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">one_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_pow","kind":"theorem","line":887,"name":"Mathlib.Tactic.Ring.one_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L887-L887"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$n»</span>)</span>)</span></span></div></div>","info":{"doc":"The main case of exponentiation of ring expressions is when `va` is a polynomial and `n` is a\nnonzero literal expression, like `(x + y)^5`. In this case we work out the polynomial completely\ninto a sum of monomials.\n\n* `x ^ 1 = x`\n* `x ^ (2*n) = x ^ n * x ^ n`\n* `x ^ (2*n+1) = x ^ n * x ^ n * x`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowNat","kind":"opaque","line":860,"name":"Mathlib.Tactic.Ring.evalPowNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L860-L885"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_bit1</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Nat.mul\">Nat.mul</a> <span class=\"fn\">2</span> <span class=\"fn\">k</span>)</span>.<a href=\"./Init/Prelude.html#Nat.add\">add</a></span> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit1","kind":"theorem","line":856,"name":"Mathlib.Tactic.Ring.pow_bit1","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L856-L858"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_bit0</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">k</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.mul\">Nat.mul</a> <span class=\"fn\">2</span> <span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_bit0","kind":"theorem","line":852,"name":"Mathlib.Tactic.Ring.pow_bit0","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L852-L854"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">1</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_one","kind":"theorem","line":850,"name":"Mathlib.Tactic.Ring.pow_one","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L850-L850"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalPos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$a»</span>)</span></span></div></div>","info":{"doc":"Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* `0 < 0` fails\n* `0 < a + b` if `0 < a` or `0 < b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalPos","kind":"opaque","line":835,"name":"Mathlib.Tactic.Ring.ExSum.evalPos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L835-L846"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalPos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$a»</span>)</span></span></div></div>","info":{"doc":"Attempts to prove that a monomial expression in `ℕ` is positive.\n\n* `0 < c` (where `c` is a numeral) is true by the normalization invariant (`c` is not zero)\n* `0 < x ^ e * b` if `0 < x` and `0 < b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalPos","kind":"opaque","line":817,"name":"Mathlib.Tactic.Ring.ExProd.evalPos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L817-L833"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">evalPos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$a»</span>)</span></span></div></div>","info":{"doc":"Attempts to prove that a polynomial expression in `ℕ` is positive.\n\n* Atoms are not (necessarily) positive\n* Sums defer to `ExSum.evalPos`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalPos","kind":"opaque","line":807,"name":"Mathlib.Tactic.Ring.ExBase.evalPos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L807-L815"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pos_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_right","kind":"theorem","line":802,"name":"Mathlib.Tactic.Ring.add_pos_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L802-L803"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pos_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pos_left","kind":"theorem","line":799,"name":"Mathlib.Tactic.Ring.add_pos_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L799-L800"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_exp_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₁</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₂</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₂</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_exp_pos","kind":"theorem","line":796,"name":"Mathlib.Tactic.Ring.mul_exp_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L796-L797"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">const_pos</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.ble\">Nat.ble</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.const_pos","kind":"theorem","line":794,"name":"Mathlib.Tactic.Ring.const_pos","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L794-L794"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span></span></div></div>","info":{"doc":"The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression.\n\n* `x ^ e = x ^ e * 1 + 0`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowAtom","kind":"def","line":784,"name":"Mathlib.Tactic.Ring.evalPowAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L784-L792"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_atom","kind":"theorem","line":782,"name":"Mathlib.Tactic.Ring.pow_atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L782-L782"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalPowProdAtom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span>)</span></span></div></div>","info":{"doc":"The fallback case for exponentiating polynomials is to use `ExBase.toProd` to just build an\nexponent expression. (This has a slightly different normalization than `evalPowAtom` because\nthe input types are different.)\n\n* `x ^ e = (x + 0) ^ e * 1`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalPowProdAtom","kind":"def","line":771,"name":"Mathlib.Tactic.Ring.evalPowProdAtom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L771-L780"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">pow_prod_atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.pow_prod_atom","kind":"theorem","line":769,"name":"Mathlib.Tactic.Ring.pow_prod_atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L769-L769"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalSub</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Subtracts two polynomials `va, vb` to get a normalized result polynomial.\n\n* `a - b = a + -b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalSub","kind":"def","line":756,"name":"Mathlib.Tactic.Ring.evalSub","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L756-L765"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sub_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sub_pf","kind":"theorem","line":753,"name":"Mathlib.Tactic.Ring.sub_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L753-L754"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">«$a»</span>)</span>)</span></span></div></div>","info":{"doc":"Negates a polynomial `va` to get another polynomial.\n\n* `-0 = 0` (for `c` coefficient)\n* `-(a₁ + a₂) = -a₁ + -a₂`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNeg","kind":"def","line":737,"name":"Mathlib.Tactic.Ring.evalNeg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L737-L749"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_add","kind":"theorem","line":733,"name":"Mathlib.Tactic.Ring.neg_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L733-L735"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">-<span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_zero","kind":"theorem","line":731,"name":"Mathlib.Tactic.Ring.neg_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L731-L731"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalNegProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">«$a»</span>)</span>)</span></span></div></div>","info":{"doc":"Negates a monomial `va` to get another monomial.\n\n* `-c = (-c)` (for `c` coefficient)\n* `-(a₁ * a₂) = a₁ * -a₂`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNegProd","kind":"def","line":708,"name":"Mathlib.Tactic.Ring.evalNegProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L708-L729"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_mul","kind":"theorem","line":705,"name":"Mathlib.Tactic.Ring.neg_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L705-L706"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">neg_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">1</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span> → <a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.neg_one_mul","kind":"theorem","line":702,"name":"Mathlib.Tactic.Ring.neg_one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L702-L703"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalZSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalZSMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Constructs the scalar multiplication `n • a`, where both `n : ℤ` and `a : α` are normalized\npolynomial expressions.\n\n* `a • b = a * b` if `α = ℤ`\n* `a • b = a' * b` otherwise, where `a'` is `↑a` with the coercion pushed as deep as possible.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalZSMul","kind":"def","line":680,"name":"Mathlib.Tactic.Ring.evalZSMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L680-L698"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_intCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_eq_intCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_intCast","kind":"theorem","line":676,"name":"Mathlib.Tactic.Ring.smul_eq_intCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L676-L678"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_int</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_int","kind":"theorem","line":674,"name":"Mathlib.Tactic.Ring.smul_int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L674-L674"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalIntCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalIntCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Int.cast` to an int polynomial to produce a polynomial in `α`.\n\n* `↑0 = 0`\n* `↑(a + b) = ↑a + ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalIntCast","kind":"opaque","line":653,"name":"Mathlib.Tactic.Ring.ExSum.evalIntCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L653-L670"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalIntCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalIntCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Int.cast` to an int monomial to produce a monomial in `α`.\n\n* `↑c = c` if `c` is a numeric literal\n* `↑(a ^ n * b) = ↑a ^ n * ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalIntCast","kind":"opaque","line":632,"name":"Mathlib.Tactic.Ring.ExProd.evalIntCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L632-L651"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalIntCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">evalIntCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">rα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\">sℤ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Int.cast` to an int polynomial to produce a polynomial in `α`.\n\n* An atom `e` causes `↑e` to be allocated as a new atom.\n* A sum delegates to `ExSum.evalIntCast`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalIntCast","kind":"opaque","line":616,"name":"Mathlib.Tactic.Ring.ExBase.evalIntCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L616-L629"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_add","kind":"theorem","line":610,"name":"Mathlib.Tactic.Ring.intCast_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L610-L612"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_zero","kind":"theorem","line":608,"name":"Mathlib.Tactic.Ring.intCast_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L608-L608"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₃</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₃</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₃</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₃</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_mul","kind":"theorem","line":604,"name":"Mathlib.Tactic.Ring.intCast_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L604-L606"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_negOfNat_Int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">intCast_negOfNat_Int</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span>)</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.intCast_negOfNat_Int","kind":"theorem","line":601,"name":"Mathlib.Tactic.Ring.intCast_negOfNat_Int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L601-L602"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_int\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_int</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_int","kind":"theorem","line":599,"name":"Mathlib.Tactic.Ring.natCast_int","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L599-L599"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalNSMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Constructs the scalar multiplication `n • a`, where both `n : ℕ` and `a : α` are normalized\npolynomial expressions.\n\n* `a • b = a * b` if `α = ℕ`\n* `a • b = ↑a * b` otherwise\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalNSMul","kind":"def","line":579,"name":"Mathlib.Tactic.Ring.evalNSMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L579-L595"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_eq_cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> → <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_eq_cast","kind":"theorem","line":576,"name":"Mathlib.Tactic.Ring.smul_eq_cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L576-L577"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">smul_nat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSMul.hSMul\">•</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.smul_nat","kind":"theorem","line":574,"name":"Mathlib.Tactic.Ring.smul_nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L574-L574"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">evalNatCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* `↑0 = 0`\n* `↑(a + b) = ↑a + ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.evalNatCast","kind":"opaque","line":559,"name":"Mathlib.Tactic.Ring.ExSum.evalNatCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L559-L570"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">evalNatCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Nat.cast` to a nat monomial to produce a monomial in `α`.\n\n* `↑c = c` if `c` is a numeric literal\n* `↑(a ^ n * b) = ↑a ^ n * ↑b`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.evalNatCast","kind":"opaque","line":544,"name":"Mathlib.Tactic.Ring.ExProd.evalNatCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L544-L557"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">evalNatCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">↑<span class=\"fn\">«$a»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Applies `Nat.cast` to a nat polynomial to produce a polynomial in `α`.\n\n* An atom `e` causes `↑e` to be allocated as a new atom.\n* A sum delegates to `ExSum.evalNatCast`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.evalNatCast","kind":"opaque","line":530,"name":"Mathlib.Tactic.Ring.ExBase.evalNatCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L530-L542"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₂</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_add","kind":"theorem","line":524,"name":"Mathlib.Tactic.Ring.natCast_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L524-L526"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_zero","kind":"theorem","line":522,"name":"Mathlib.Tactic.Ring.natCast_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L522-L522"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b₁ </span><span class=\"fn\">b₃</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₃</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> → <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a₃</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₃</span> → <span class=\"fn\">↑(<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_mul","kind":"theorem","line":518,"name":"Mathlib.Tactic.Ring.natCast_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L518-L520"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">natCast_nat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n</span>.<a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">rawCast</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.natCast_nat","kind":"theorem","line":516,"name":"Mathlib.Tactic.Ring.natCast_nat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L516-L516"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Multiplies two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 * b = 0`\n* `(a₁ + a₂) * b = (a₁ * b) + (a₂ * b)`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul","kind":"def","line":499,"name":"Mathlib.Tactic.Ring.evalMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L499-L512"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂ </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\"><span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → (<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span>) <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_mul","kind":"theorem","line":496,"name":"Mathlib.Tactic.Ring.add_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L496-L497"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">zero_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.zero_mul","kind":"theorem","line":494,"name":"Mathlib.Tactic.Ring.zero_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L494-L494"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalMul₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Multiplies a monomial `va` to a polynomial `vb` to get a normalized result polynomial.\n\n* `a * 0 = 0`\n* `a * (b₁ + b₂) = (a * b₁) + (a * b₂)`\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMul₁","kind":"def","line":479,"name":"Mathlib.Tactic.Ring.evalMul₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L479-L492"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂ </span><span class=\"fn\">d</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\"><span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">d</span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_add","kind":"theorem","line":475,"name":"Mathlib.Tactic.Ring.mul_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L475-L477"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_zero","kind":"theorem","line":473,"name":"Mathlib.Tactic.Ring.mul_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L473-L473"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalMulProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n  (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalMulProd","kind":"opaque","line":430,"name":"Mathlib.Tactic.Ring.evalMulProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L430-L471"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pp_pf_overlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">ea </span><span class=\"fn\">eb </span><span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">ea</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">eb</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">e</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">ea</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">eb</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pp_pf_overlap","kind":"theorem","line":426,"name":"Mathlib.Tactic.Ring.mul_pp_pf_overlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L426-L428"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pf_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b₃ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b₃</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_right","kind":"theorem","line":422,"name":"Mathlib.Tactic.Ring.mul_pf_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L422-L424"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_pf_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₃ </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₂</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a₃</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_pf_left","kind":"theorem","line":418,"name":"Mathlib.Tactic.Ring.mul_pf_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L418-L420"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">mul_one</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.mul_one","kind":"theorem","line":416,"name":"Mathlib.Tactic.Ring.mul_one","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L416-L416"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.one_mul","kind":"theorem","line":414,"name":"Mathlib.Tactic.Ring.one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L414-L414"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalAdd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Adds two polynomials `va, vb` together to get a normalized result polynomial.\n\n* `0 + b = b`\n* `a + 0 = a`\n* `a * x + a * y = a * (x + y)` (for `x`, `y` coefficients; uses `evalAddOverlap`)\n* `(a₁ + a₂) + (b₁ + b₂) = a₁ + (a₂ + (b₁ + b₂))` (if `a₁.lt b₁`)\n* `(a₁ + a₂) + (b₁ + b₂) = b₁ + ((a₁ + a₂) + b₂)` (if not `a₁.lt b₁`)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAdd","kind":"opaque","line":382,"name":"Mathlib.Tactic.Ring.evalAdd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L382-L410"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_gt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b₂ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_gt","kind":"theorem","line":379,"name":"Mathlib.Tactic.Ring.add_pf_add_gt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L379-L380"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_lt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₂ </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a₁</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_lt","kind":"theorem","line":377,"name":"Mathlib.Tactic.Ring.add_pf_add_lt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L377-L377"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_overlap_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> (<span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₁</span>) <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₄</span> : <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap_zero","kind":"theorem","line":373,"name":"Mathlib.Tactic.Ring.add_pf_add_overlap_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L373-L375"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_overlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a₁ </span><span class=\"fn\">a₂ </span><span class=\"fn\">b₁ </span><span class=\"fn\">b₂ </span><span class=\"fn\">c₁ </span><span class=\"fn\">c₂</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> → <span class=\"fn\"><span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₂</span> → <span class=\"fn\">a₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">a₂</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> (<span class=\"fn\">b₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b₂</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c₂</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_overlap","kind":"theorem","line":369,"name":"Mathlib.Tactic.Ring.add_pf_add_overlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L369-L371"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_add_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_add_zero","kind":"theorem","line":367,"name":"Mathlib.Tactic.Ring.add_pf_add_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L367-L367"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_pf_zero_add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_pf_zero_add","kind":"theorem","line":365,"name":"Mathlib.Tactic.Ring.add_pf_zero_add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L365-L365"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">evalAddOverlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\">Overlap</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">«$b»</span>)</span>)</span></span></div></div>","info":{"doc":"Given monomials `va, vb`, attempts to add them together to get another monomial.\nIf the monomials are not compatible, returns `none`.\nFor example, `xy + 2xy = 3xy` is a `.nonzero` overlap, while `xy + xz` returns `none`\nand `xy + -xy = 0` is a `.zero` overlap.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.evalAddOverlap","kind":"def","line":338,"name":"Mathlib.Tactic.Ring.evalAddOverlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L338-L363"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_overlap_pf_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> (<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span>) <span class=\"fn\">0</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> (<span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span>) <span class=\"fn\">0</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf_zero","kind":"theorem","line":329,"name":"Mathlib.Tactic.Ring.add_overlap_pf_zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L329-L331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">add_overlap_pf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">c</span> : <span class=\"fn\">R</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pq_pf</span> : <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">e</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.add_overlap_pf","kind":"theorem","line":326,"name":"Mathlib.Tactic.Ring.add_overlap_pf","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L326-L327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Overlap</span>.<span class=\"name\">nonzero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span>)</span> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\">Overlap</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"The expression `e` (the sum of monomials) is equal to another monomial\n(with nonzero leading coefficient). ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.nonzero","kind":"ctor","line":318,"name":"Mathlib.Tactic.Ring.Overlap.nonzero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L318-L320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Overlap</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Meta.NormNum.IsNat</a> <span class=\"fn\">«$e»</span> <span class=\"fn\">0</span></span>)</span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\">Overlap</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"The expression `e` (the sum of monomials) is equal to `0`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap.zero","kind":"ctor","line":316,"name":"Mathlib.Tactic.Ring.Overlap.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L316-L317"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Overlap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Two monomials are said to \"overlap\" if they differ by a constant factor, in which case the\nconstants just add. When this happens, the constant may be either zero (if the monomials cancel)\nor nonzero (if they add up); the zero case is handled specially.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Overlap","kind":"inductive","line":310,"name":"Mathlib.Tactic.Ring.Overlap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L310-L320"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">coeff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span> → <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a></span></div></div>","info":{"doc":"Get the leading coefficient of an `ExProd`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.coeff","kind":"def","line":304,"name":"Mathlib.Tactic.Ring.ExProd.coeff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L304-L307"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">toSum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">v</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">0</span>)</span></span></div></div>","info":{"doc":"Embed `ExProd` in `ExSum` by adding 0. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.toSum","kind":"def","line":300,"name":"Mathlib.Tactic.Ring.ExProd.toSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L300-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">toProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">va</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">vb</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$b»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span>)</span></span></div></div>","info":{"doc":"Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.toProd","kind":"def","line":295,"name":"Mathlib.Tactic.Ring.ExBase.toProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L295-L298"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNegNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>) → <span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) → <span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>) → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></span></span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const q h` for `q = -(n / d)`\nand `h` a proof that `(d : α) ≠ 0`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNNRat","kind":"def","line":284,"name":"Mathlib.Tactic.Ring.ExProd.mkNegNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L284-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNNRat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNNRat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionSemiring\">DivisionSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">q</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>) → <span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">d</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>) → <span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>) → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></span></span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const q h` for `q = n / d`\nand `h` a proof that `(d : α) ≠ 0`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNNRat","kind":"def","line":275,"name":"Mathlib.Tactic.Ring.ExProd.mkNNRat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L275-L282"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNegNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>) → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const (-n)`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNegNat","kind":"def","line":267,"name":"Mathlib.Tactic.Ring.ExProd.mkNegNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L267-L273"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mkNat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"Constructs the expression corresponding to `.const n`.\n(The `.const` constructor does not check that the expression is correct.)\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mkNat","kind":"def","line":259,"name":"Mathlib.Tactic.Ring.ExProd.mkNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L259-L265"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedResultOfSigmaQuoted</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted","kind":"instance","line":252,"name":"Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L252-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">proof</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">unknown_1</span>)</span></div></div>","info":{"doc":"A proof that the original expression is equal to the normalized result. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.proof","kind":"def","line":250,"name":"Mathlib.Tactic.Ring.Result.proof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L250-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.val\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">val</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">E</span> <span class=\"fn\"><span class=\"fn\">self</span>.<a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr\">expr</a></span></span></div></div>","info":{"doc":"The data associated to the normalization. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.val","kind":"def","line":248,"name":"Mathlib.Tactic.Ring.Result.val","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L248-L248"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">expr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span></div></div>","info":{"doc":"The normalized result. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.expr","kind":"def","line":246,"name":"Mathlib.Tactic.Ring.Result.expr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L246-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expr</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">val</span> : <span class=\"fn\"><span class=\"fn\">E</span> <span class=\"fn\">expr</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">proof</span> : <span class=\"fn\">Q(<span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$expr»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\">Result</a> <span class=\"fn\">E</span> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result.mk","kind":"ctor","line":244,"name":"Mathlib.Tactic.Ring.Result.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L244-L244"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">Result</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">E</span> : <span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span> → <a href=\"./foundational_types.html\">Type</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The result of evaluating an (unnormalized) expression `e` into the type family `E`\n(one of `ExSum`, `ExProd`, `ExBase`) is a (normalized) element `e'`\nand a representation `E e'` for it, and a proof of `e = e'`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.Result","kind":"structure","line":239,"name":"Mathlib.Tactic.Ring.Result","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L239-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sβ</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$β»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$β»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sβ</span> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"Converts `ExSum sα` to `ExSum sβ`, assuming `sα` and `sβ` are defeq. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cast","kind":"opaque","line":230,"name":"Mathlib.Tactic.Ring.ExSum.cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L230-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sβ</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$β»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$β»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sβ</span> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"Converts `ExProd sα` to `ExProd sβ`, assuming `sα` and `sβ` are defeq. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cast","kind":"opaque","line":223,"name":"Mathlib.Tactic.Ring.ExProd.cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L223-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">cast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sβ</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$β»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$β»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sβ</span> <span class=\"fn\">a</span></span></span></span></div></div>","info":{"doc":"Converts `ExBase sα` to `ExBase sβ`, assuming `sα` and `sβ` are defeq. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cast","kind":"opaque","line":216,"name":"Mathlib.Tactic.Ring.ExBase.cast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L216-L221"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedSigmaQuotedExProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd","kind":"instance","line":212,"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L212-L212"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedSigmaQuotedExSum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum","kind":"instance","line":211,"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L211-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instInhabitedSigmaQuotedExBase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">((<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) × <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase","kind":"instance","line":210,"name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L210-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">cmp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span></span></div></div>","info":{"doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.cmp","kind":"opaque","line":198,"name":"Mathlib.Tactic.Ring.ExSum.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L198-L205"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">cmp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span></span></div></div>","info":{"doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.cmp","kind":"opaque","line":189,"name":"Mathlib.Tactic.Ring.ExProd.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L189-L196"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">cmp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span></span></div></div>","info":{"doc":"A total order on normalized expressions.\nThis is not an `Ord` instance because it is heterogeneous.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.cmp","kind":"opaque","line":177,"name":"Mathlib.Tactic.Ring.ExBase.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L177-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>","info":{"doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.eq","kind":"opaque","line":167,"name":"Mathlib.Tactic.Ring.ExSum.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L167-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>","info":{"doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.eq","kind":"opaque","line":159,"name":"Mathlib.Tactic.Ring.ExProd.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L159-L165"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>","info":{"doc":"Equality test for expressions. This is not a `BEq` instance because it is heterogeneous. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.eq","kind":"opaque","line":151,"name":"Mathlib.Tactic.Ring.ExBase.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L151-L157"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">add</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">«$b»</span>)</span></span></span></span></div></div>","info":{"doc":"A sum `a + b` is a polynomial if `a` is a monomial and `b` is another polynomial. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.add","kind":"ctor","line":144,"name":"Mathlib.Tactic.Ring.ExSum.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L144-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">0</span>)</span></span></div></div>","info":{"doc":"Zero is a polynomial. `e` is the expression `0`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum.zero","kind":"ctor","line":142,"name":"Mathlib.Tactic.Ring.ExSum.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L142-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) → <a href=\"./foundational_types.html\">Type</a></span></span></div></div>","info":{"doc":"A polynomial expression, which is a sum of monomials. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum","kind":"inductive","line":140,"name":"Mathlib.Tactic.Ring.ExSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L140-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">x</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">x</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\">sℕ</a> <span class=\"fn\">e</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">q(<span class=\"fn\">«$x»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$e»</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">«$b»</span>)</span></span></span></span></span></div></div>","info":{"doc":"A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\nand `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\na polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.mul","kind":"ctor","line":134,"name":"Mathlib.Tactic.Ring.ExProd.mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L134-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">const</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">value</span> : <a href=\"./Init/Data/Rat/Basic.html#Rat\">ℚ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyp</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\nIf `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd.const","kind":"ctor","line":131,"name":"Mathlib.Tactic.Ring.ExProd.const","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L131-L133"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) → <a href=\"./foundational_types.html\">Type</a></span></span></div></div>","info":{"doc":"A monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd","kind":"inductive","line":126,"name":"Mathlib.Tactic.Ring.ExProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L126-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">sum</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></span></div></div>","info":{"doc":"A sum of monomials. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.sum","kind":"ctor","line":123,"name":"Mathlib.Tactic.Ring.ExBase.sum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L123-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">atom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">id</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">e</span></span></div></div>","info":{"doc":"An atomic expression `e` with id `id`.\n\nAtomic expressions are those which `ring` cannot parse any further.\nFor instance, `a + (a % b)` has `a` and `(a % b)` as atoms.\nThe `ring1` tactic does not normalize the subexpressions in atoms, but `ring_nf` does.\n\nAtoms in fact represent equivalence classes of expressions, modulo definitional equality.\nThe field `index : ℕ` should be a unique number for each class,\nwhile `value : expr` contains a representative of this class.\nThe function `resolve_atom` determines the appropriate atom for a given expression.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase.atom","kind":"ctor","line":110,"name":"Mathlib.Tactic.Ring.ExBase.atom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L110-L122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$α»</span></span>)</span> → <span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>) → <a href=\"./foundational_types.html\">Type</a></span></span></div></div>","info":{"doc":"The base `e` of a normalized exponent expression. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase","kind":"inductive","line":108,"name":"Mathlib.Tactic.Ring.ExBase","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L108-L124"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sℤ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span></div></div>","info":{"doc":"A typed expression of type `CommSemiring ℤ` used when we are working on\nring subexpressions of type `ℤ`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℤ","kind":"def","line":100,"name":"Mathlib.Tactic.Ring.sℤ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L100-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">sℕ</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></div></div>","info":{"doc":"A typed expression of type `CommSemiring ℕ` used when we are working on\nring subexpressions of type `ℕ`.\n","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.sℕ","kind":"def","line":94,"name":"Mathlib.Tactic.Ring.sℕ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L94-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instCommSemiringInt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></div></div>","info":{"doc":"A shortcut instance for `CommSemiring ℤ` used by ring. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringInt","kind":"def","line":91,"name":"Mathlib.Tactic.Ring.instCommSemiringInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L91-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">instCommSemiringNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"A shortcut instance for `CommSemiring ℕ` used by ring. ","docLink":"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.instCommSemiringNat","kind":"def","line":88,"name":"Mathlib.Tactic.Ring.instCommSemiringNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Ring/Basic.lean#L88-L89"}}],"imports":["Init","Mathlib.Tactic.NormNum.Inv","Mathlib.Tactic.NormNum.Pow","Mathlib.Util.AtomM"],"instances":[{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExBase","typeNames":["Sigma"]},{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExSum","typeNames":["Sigma"]},{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedSigmaQuotedExProd","typeNames":["Sigma"]},{"className":"Inhabited","name":"Mathlib.Tactic.Ring.instInhabitedResultOfSigmaQuoted","typeNames":["Mathlib.Tactic.Ring.Result"]},{"className":"Mathlib.Tactic.Ring.CSLiftVal","name":"Mathlib.Tactic.Ring.instCSLiftValLift","typeNames":["Mathlib.Tactic.Ring.CSLift.lift"]}],"name":"Mathlib.Tactic.Ring.Basic"}
{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.extractRewriteHypEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Erw?</span>.<span class=\"name\">extractRewriteHypEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Checks that the input `Expr` represents a proof produced by `(e)rw at` and returns the type of the\nLHS of the equality (from the lemma used).\nThis will be defeq to the hypothesis being written, but not necessarily reducibly so.\n","docLink":"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.extractRewriteHypEq","kind":"def","line":99,"name":"Mathlib.Tactic.Erw?.extractRewriteHypEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/ErwQuestion.lean#L99-L111"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.extractRewriteEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Erw?</span>.<span class=\"name\">extractRewriteEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Checks that the input `Expr` represents a proof produced by `(e)rw` and returns the types of the\nLHS of the equality being written (one from the target, the other from the lemma used).\nThese will be defeq, but not necessarily reducibly so.\n","docLink":"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.extractRewriteEq","kind":"def","line":83,"name":"Mathlib.Tactic.Erw?.extractRewriteEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/ErwQuestion.lean#L83-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.logDiffs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Erw?</span>.<span class=\"name\">logDiffs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tk</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Unit\">Unit</a> → <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a>)</span>)</span> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Check if two expressions are different at reducible transparency.\nAttempt to log an info message for the first subexpressions which are different\n(but agree at default transparency).\n\nAlso returns an array of messages for the `verbose` report.\n","docLink":"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.logDiffs","kind":"def","line":41,"name":"Mathlib.Tactic.Erw?.logDiffs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/ErwQuestion.lean#L41-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.erw?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Erw?</span>.<span class=\"name\">erw?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`erw? [r, ...]` calls `erw [r, ...]` (at hypothesis `h` if written `erw [r, ...] at h`),\nand then attempts to identify any subexpression which would block the use of `rw` instead.\nIt does so by identifying subexpressions which are defeq, but not at reducible transparency.\n","docLink":"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.erw?","kind":"def","line":31,"name":"Mathlib.Tactic.Erw?.erw?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/ErwQuestion.lean#L31-L36"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.tactic.erw?.verbose\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Erw?</span>.<span class=\"name\">tactic</span>.<span class=\"name\">erw?</span>.<span class=\"name\">verbose</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"If set to `true`, `erw?` will log more information as it attempts to identify subexpressions\nwhich would block the use of `rw` instead.\n","docLink":"./Mathlib/Tactic/ErwQuestion.html#Mathlib.Tactic.Erw?.tactic.erw?.verbose","kind":"opaque","line":21,"name":"Mathlib.Tactic.Erw?.tactic.erw?.verbose","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/ErwQuestion.lean#L21-L29"}}],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Rewrite"],"instances":[],"name":"Mathlib.Tactic.ErwQuestion"}
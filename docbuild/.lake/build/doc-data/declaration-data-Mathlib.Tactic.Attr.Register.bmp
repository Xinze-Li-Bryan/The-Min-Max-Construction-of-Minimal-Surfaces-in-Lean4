{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mon_tauto_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">mon_tauto_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mon_tauto_proc","kind":"def","line":95,"name":"Parser.Attr.mon_tauto_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L95-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mon_tauto\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">mon_tauto</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`mon_tauto` is a simp set to prove tautologies about morphisms from some (tensor) power of `M`\nto `M`, where `M` is a (commutative) monoid object in a (braided) monoidal category.\n\n**This `simp` set is incompatible with the standard simp set.**\nIf you want to use it, make sure to add the following to your simp call to disable the problematic\ndefault simp lemmas:\n```\n-MonoidalCategory.whiskerLeft_id, -MonoidalCategory.id_whiskerRight,\n-MonoidalCategory.tensor_comp, -MonoidalCategory.tensor_comp_assoc,\n-MonObj.mul_assoc, -MonObj.mul_assoc_assoc\n```\n\nThe general algorithm it follows is to push the associators `α_` and commutators `β_` inwards until\nthey cancel against the right sequence of multiplications.\n\nThis approach is justified by the fact that a tautology in the language of (commutative) monoid\nobjects \"remembers\" how it was proved: Every use of a (commutative) monoid object axiom inserts a\nunitor, associator or commutator, and proving a tautology simply amounts to undoing those moves as\nprescribed by the presence of unitors, associators and commutators in its expression.\n\nThis simp set is opiniated about its normal form, which is why it cannot be used concurrently with\nsome of the simp lemmas in the standard simp set:\n* It eliminates all mentions of whiskers by rewriting them to tensored homs,\n  which goes against `whiskerLeft_id` and `id_whiskerRight`:\n  `X ◁ f = 𝟙 X ⊗ₘ f`, `f ▷ X = 𝟙 X ⊗ₘ f`.\n  This goes against `whiskerLeft_id` and `id_whiskerRight` in the standard simp set.\n* It collapses compositions of tensored homs to the tensored hom of the compositions,\n  which goes against `tensor_comp`:\n  `(f₁ ⊗ₘ g₁) ≫ (f₂ ⊗ₘ g₂) = (f₁ ≫ f₂) ⊗ₘ (g₁ ≫ g₂)`. TODO: Isn't this direction Just Better?\n* It cancels the associators against multiplications,\n  which goes against `mul_assoc`:\n  `(α_ M M M).hom ≫ (𝟙 M ⊗ₘ μ) ≫ μ = (μ ⊗ₘ 𝟙 M) ≫ μ`,\n  `(α_ M M M).inv ≫ (μ ⊗ₘ 𝟙 M) ≫ μ = (𝟙 M ⊗ₘ μ) ≫ μ`\n* It unfolds non-primitive coherence isomorphisms, like the tensor strengths `tensorμ`, `tensorδ`.\n","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mon_tauto","kind":"def","line":95,"name":"Parser.Attr.mon_tauto","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L95-L130"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.pnat_to_nat_coe\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">pnat_to_nat_coe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A simp set for the `pnat_to_nat` tactic. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.pnat_to_nat_coe","kind":"def","line":92,"name":"Parser.Attr.pnat_to_nat_coe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L92-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.pnat_to_nat_coe_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">pnat_to_nat_coe_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.pnat_to_nat_coe_proc","kind":"def","line":92,"name":"Parser.Attr.pnat_to_nat_coe_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L92-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_coe\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">enat_to_nat_coe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A simp set for pushing coercions from `ℕ` to `ℕ∞` in `enat_to_nat`. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_coe","kind":"def","line":89,"name":"Parser.Attr.enat_to_nat_coe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L89-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_coe_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">enat_to_nat_coe_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_coe_proc","kind":"def","line":89,"name":"Parser.Attr.enat_to_nat_coe_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L89-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_top_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">enat_to_nat_top_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_top_proc","kind":"def","line":86,"name":"Parser.Attr.enat_to_nat_top_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L86-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_top\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">enat_to_nat_top</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A simp set for simplifying expressions involving `⊤` in `enat_to_nat`. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.enat_to_nat_top","kind":"def","line":86,"name":"Parser.Attr.enat_to_nat_top","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L86-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.fin_omega\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">fin_omega</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A simp set for the `fin_omega` wrapper around `omega`. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.fin_omega","kind":"def","line":83,"name":"Parser.Attr.fin_omega","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L83-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.fin_omega_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">fin_omega_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.fin_omega_proc","kind":"def","line":83,"name":"Parser.Attr.fin_omega_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L83-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.is_poly\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">is_poly</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A stub attribute for `is_poly`. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.is_poly","kind":"def","line":80,"name":"Parser.Attr.is_poly","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L80-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.nontriviality\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">nontriviality</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `@[nontriviality]` simp set is used by the `nontriviality` tactic to automatically\ndischarge theorems about the trivial case (where we know `Subsingleton α` and many theorems\nin e.g. groups are trivially true). ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.nontriviality","kind":"def","line":75,"name":"Parser.Attr.nontriviality","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L75-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.nontriviality_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">nontriviality_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.nontriviality_proc","kind":"def","line":75,"name":"Parser.Attr.nontriviality_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L75-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.ghost_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">ghost_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification rules for ghost equations. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.ghost_simps","kind":"def","line":72,"name":"Parser.Attr.ghost_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L72-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.ghost_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">ghost_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.ghost_simps_proc","kind":"def","line":72,"name":"Parser.Attr.ghost_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L72-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.typevec_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">typevec_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.typevec_proc","kind":"def","line":69,"name":"Parser.Attr.typevec_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L69-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.typevec\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">typevec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"simp set for the manipulation of typevec and arrow expressions ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.typevec","kind":"def","line":69,"name":"Parser.Attr.typevec","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L69-L70"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.integral_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">integral_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.integral_simps_proc","kind":"def","line":66,"name":"Parser.Attr.integral_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L66-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.integral_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">integral_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simp set for integral rules. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.integral_simps","kind":"def","line":66,"name":"Parser.Attr.integral_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L66-L67"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mfld_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">mfld_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mfld_simps_proc","kind":"def","line":52,"name":"Parser.Attr.mfld_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L52-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mfld_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">mfld_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The simpset `mfld_simps` records several simp lemmas that are\nespecially useful in manifolds. It is a subset of the whole set of simp lemmas, but it makes it\npossible to have quicker proofs (when used with `squeeze_simp` or `simp only`) while retaining\nreadability.\n\nThe typical use case is the following, in a file on manifolds:\nIf `simp [foo, bar]` is slow, replace it with `squeeze_simp [foo, bar, mfld_simps]` and paste\nits output. The list of lemmas should be reasonable (contrary to the output of\n`squeeze_simp [foo, bar]` which might contain tens of lemmas), and the outcome should be quick\nenough.\n","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.mfld_simps","kind":"def","line":52,"name":"Parser.Attr.mfld_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L52-L64"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.zify_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">zify_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The simpset `zify_simps` is used by the tactic `zify` to move expressions from `ℕ` to `ℤ`\nwhich gives a well-behaved subtraction. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.zify_simps","kind":"def","line":48,"name":"Parser.Attr.zify_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L48-L50"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.zify_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">zify_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.zify_simps_proc","kind":"def","line":48,"name":"Parser.Attr.zify_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L48-L50"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.qify_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">qify_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.qify_simps_proc","kind":"def","line":44,"name":"Parser.Attr.qify_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L44-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.qify_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">qify_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The simpset `qify_simps` is used by the tactic `qify` to move expressions from `ℕ` or `ℤ` to `ℚ`\nwhich gives a well-behaved division. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.qify_simps","kind":"def","line":44,"name":"Parser.Attr.qify_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L44-L46"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rify_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">rify_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The simpset `rify_simps` is used by the tactic `rify` to move expressions from `ℕ`, `ℤ`, or\n`ℚ` to `ℝ`. ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rify_simps","kind":"def","line":40,"name":"Parser.Attr.rify_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L40-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rify_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">rify_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rify_simps_proc","kind":"def","line":40,"name":"Parser.Attr.rify_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L40-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rclike_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">rclike_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"\"Simp attribute for lemmas about `RCLike`\" ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rclike_simps","kind":"def","line":37,"name":"Parser.Attr.rclike_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L37-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rclike_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">rclike_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.rclike_simps_proc","kind":"def","line":37,"name":"Parser.Attr.rclike_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L37-L38"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.parity_simps_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">parity_simps_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.parity_simps_proc","kind":"def","line":34,"name":"Parser.Attr.parity_simps_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L34-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.parity_simps\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">parity_simps</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simp attribute for lemmas about `Even` ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.parity_simps","kind":"def","line":34,"name":"Parser.Attr.parity_simps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L34-L35"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.monad_norm\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">monad_norm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simp set for `functor_norm` ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.monad_norm","kind":"def","line":31,"name":"Parser.Attr.monad_norm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L31-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.monad_norm_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">monad_norm_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.monad_norm_proc","kind":"def","line":31,"name":"Parser.Attr.monad_norm_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L31-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.functor_norm\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">functor_norm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simp set for `functor_norm` ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.functor_norm","kind":"def","line":21,"name":"Parser.Attr.functor_norm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L21-L22"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.functor_norm_proc\"><span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">functor_norm_proc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Simplification procedure ","docLink":"./Mathlib/Tactic/Attr/Register.html#Parser.Attr.functor_norm_proc","kind":"def","line":21,"name":"Parser.Attr.functor_norm_proc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Tactic/Attr/Register.lean#L21-L22"}}],"imports":["Init","Mathlib.Init","Lean.Meta.Tactic.Simp.SimpTheorems","Lean.Meta.Tactic.Simp.RegisterCommand","Lean.LabelAttribute"],"instances":[],"name":"Mathlib.Tactic.Attr.Register"}
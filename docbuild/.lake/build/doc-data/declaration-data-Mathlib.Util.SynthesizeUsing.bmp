{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic'\"><span class=\"name\">synthesizeUsingTactic'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></div></div>","info":{"doc":"`synthesizeUsing' type tacticSyntax` synthesizes an element of type `type` by evaluating the\ngiven tactic syntax.\n\nExample:\n```lean\nlet e ← synthesizeUsingTactic' ty (← `(tactic| norm_num))\n```\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsingTactic`.\n\nIf you need to insert expressions into a tactic proof, then you might use `synthesizeUsing'`\ndirectly, since the `TacticM` monad has access to the `TermElabM` monad. For example, here\nis a term elaborator that wraps the `simp at ...` tactic:\n```\ndef simpTerm (e : Expr) : MetaM Expr := do\n  let mvar ← Meta.mkFreshTypeMVar\n  let e' ← synthesizeUsing' mvar\n    (do evalTactic (← `(tactic| have h := $(← Term.exprToSyntax e); simp at h; exact h)))\n  -- Note: `simp` does not always insert type hints, so to ensure that we get a term\n  -- with the simplified type (as opposed to one that is merely defeq), we should add\n  -- a type hint ourselves.\n  Meta.mkExpectedTypeHint e' mvar\n\nelab \"simpTerm% \" t:term : term => do simpTerm (← Term.elabTerm t none)\n```\n","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic'","kind":"def","line":62,"name":"synthesizeUsingTactic'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Util/SynthesizeUsing.lean#L62-L90"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic\"><span class=\"name\">synthesizeUsingTactic</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span>)</span></div></div>","info":{"doc":"`synthesizeUsing type tacticSyntax` synthesizes an element of type `type` by evaluating the\ngiven tactic syntax.\n\nExample:\n```lean\nlet (gs, e) ← synthesizeUsingTactic ty (← `(tactic| congr!))\n```\n\nThe tactic `tac` is allowed to leave goals open, and these remain as metavariables in the\nreturned expression.\n","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsingTactic","kind":"def","line":46,"name":"synthesizeUsingTactic","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Util/SynthesizeUsing.lean#L46-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing'\"><span class=\"name\">synthesizeUsing'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span></span></div></div>","info":{"doc":"`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic must solve for all goals, in contrast to `synthesizeUsing`.\n","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing'","kind":"def","line":33,"name":"synthesizeUsing'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Util/SynthesizeUsing.lean#L33-L44"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing\"><span class=\"name\">synthesizeUsing</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tac</span> : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">Q(<span class=\"fn\">«$type»</span>)</span>)</span></div></div>","info":{"doc":"`synthesizeUsing type tac` synthesizes an element of type `type` using tactic `tac`.\n\nThe tactic `tac` is allowed to leave goals open, and these remain as metavariables in the\nreturned expression.\n","docLink":"./Mathlib/Util/SynthesizeUsing.html#synthesizeUsing","kind":"def","line":18,"name":"synthesizeUsing","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/a43dd5b1315afdbfd01ad27674f1c37e7ce763e6/Mathlib/Util/SynthesizeUsing.lean#L18-L31"}}],"imports":["Init","Mathlib.Init","Lean.Elab.Tactic.Basic","Qq"],"instances":[],"name":"Mathlib.Util.SynthesizeUsing"}
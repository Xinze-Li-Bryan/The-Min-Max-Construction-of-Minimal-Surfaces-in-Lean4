{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.¬´termMk_rpc_widget%_¬ª\"><span class=\"name\">ProofWidgets</span>.<span class=\"name\">¬´termMk_rpc_widget%_¬ª</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The elaborator `mk_rpc_widget%` allows writing certain widgets in Lean instead of JavaScript.\nSpecifically, it translates an RPC method of type `MyProps ‚Üí RequestM (RequestTask Html)`\ninto a widget component of type `Component MyProps`.\n\nEven more specifically, we can write:\n```lean\nopen Lean Server\n\nstructure MyProps where\n  ...\n  deriving RpcEncodable\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  ...\n\n@[widget_module]\ndef MyComponent : Component MyProps :=\n  mk_rpc_widget% MyComponent.rpc\n```\n\nThis is convenient because we can program the logic that computes an output HTML tree\ngiven input props in Lean directly.\n\n‚ö†Ô∏è However, note that there are several limitations on what such component can do\ncompared to ones written natively in TypeScript or JavaScript:\n- It must be pure, i.e. cannot directly store any React state.\n  Child components may store state as usual.\n- It cannot pass closures as props to the child components that it returns.\n  For example, it is not currently possible to write click event handlers in Lean\n  and pass them to a `<button onClick={..}>` child.\n- Every time the input props change, the infoview has to send a message to the Lean server\n  in order to invoke the RPC method.\n  Thus there can be a noticeable visual delay between the input props changing\n  and the display updating.\n  Consequently, components whose props change at a high frequency\n  (e.g. depending on the mouse position)\n  should not be implemented using this method.\n\nüí° Note that an inverse transformation is already possible.\nGiven `MyComponent : Component MyProps`, we can write:\n```lean\nopen Lean Server\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    return Html.ofComponent MyComponent ps #[]\n```\n","docLink":"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.¬´termMk_rpc_widget%_¬ª","kind":"def","line":14,"name":"ProofWidgets.¬´termMk_rpc_widget%_¬ª","sourceLink":"https://github.com/leanprover-community/ProofWidgets4/blob/556caed0eadb7901e068131d1be208dd907d07a2/ProofWidgets/Component/OfRpcMethod.lean#L14-L91"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.ofRpcMethodTemplate\"><span class=\"name\">ProofWidgets</span>.<span class=\"name\">ofRpcMethodTemplate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>","info":{"doc":"","docLink":"./ProofWidgets/Component/OfRpcMethod.html#ProofWidgets.ofRpcMethodTemplate","kind":"def","line":12,"name":"ProofWidgets.ofRpcMethodTemplate","sourceLink":"https://github.com/leanprover-community/ProofWidgets4/blob/556caed0eadb7901e068131d1be208dd907d07a2/ProofWidgets/Component/OfRpcMethod.lean#L12-L12"}}],"imports":["Init","Lean.Elab.ElabRules","ProofWidgets.Component.Basic","ProofWidgets.Data.Html","ProofWidgets.Cancellable","Batteries.Tactic.OpenPrivate"],"instances":[],"name":"ProofWidgets.Component.OfRpcMethod"}